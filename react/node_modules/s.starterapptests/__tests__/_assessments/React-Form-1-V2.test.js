import React from "react";
import { MemoryRouter } from "react-router-dom";
import { configure, mount } from "enzyme";
import Product from "../../components/codeChallenge/Product";
import ProductCard from "../../components/codeChallenge/ProductCard";
import App from "../../App";
import Adapter from "@wojtekmaj/enzyme-adapter-react-17";
import productService from "../../components/codeChallenge/services/productService";
import { act } from "react-dom/test-utils";

configure({ adapter: new Adapter() });

const axios = require("axios");
jest.mock("axios");
jest.mock("../../components/codeChallenge/services/productService");

const mockProduct = {
  id: "1985",
  name: "Rocktopus",
  manufacturer: "3D Printed",
  description: "A weird 3D combo of The Rock and an octopus",
  cost: 30,
  status: "active",
};

describe("React Forms #1", () => {
  it("App.jsx has a route for Product", () => {
    const wrapper = mount(
      <MemoryRouter initialEntries={["/product"]}>
        <App />
      </MemoryRouter>
    );
    expect(wrapper.find(Product)).toHaveLength(1);
  });

  let productComponent;
  beforeEach(() => {
    productComponent = mount(<Product />);
  });
  afterEach(() => {
    jest.restoreAllMocks();
    productComponent.update();
  });

  it("The form element is rendered. HINT: the element should be lowercase", () => {
    expect(productComponent.exists("form")).toEqual(true);
  });

  it("form-group classes exist on the divs around each form item", () => {
    expect(productComponent.exists("div.form-group")).toEqual(true);
  });

  const inputsExpected = ["name", "description", "manufacturer", "cost"];
  for (const inputName of inputsExpected) {
    it(`An input for ${inputName} exists on the form. HINT: do you have an id property?`, () => {
      expect(
        productComponent.containsMatchingElement(<input id={inputName} />)
      ).toBeTruthy();
    });
  }

  it("A select for status exists on the form. HINT: do you have an id property?", () => {
    expect(productComponent.find("select#status")).toHaveLength(1);
  });

  it("An option 'active' exists on the form. HINT: do you have a value property? Did you add the right text?", () => {
    expect(
      productComponent.find("#status > option[value='active']")
    ).toHaveLength(1);
    expect(
      productComponent
        .find("#status > option[value='active']")
        .text()
        .toLowerCase()
    ).toEqual("active");
  });

  it("An option 'inactive' exists on the form. HINT: do you have a value property? Did you add the right text?", () => {
    expect(
      productComponent.find("#status > option[value='inactive']")
    ).toHaveLength(1);
    expect(
      productComponent
        .find("#status > option[value='inactive']")
        .text()
        .toLowerCase()
    ).toEqual("inactive");
  });

  const filedsToFill = [
    "name",
    "description",
    "manufacturer",
    "cost",
    "status",
  ];
  for (const field of filedsToFill) {
    it(`${field} input field should have an onChange handler that updates its value correctly. HINT: Remember to add id, name and value properties`, () => {
      expect(productComponent.find("#" + field).prop("onChange")).toEqual(
        expect.any(Function)
      );

      // simulate change form fields with mockProduct
      const name = productComponent
        .find("#" + field)
        .props()
        .name.trim();
      productComponent.find("#" + field).simulate("change", {
        target: { value: mockProduct[field], name: name },
      });

      expect(productComponent.find("#" + field).prop("value")).toEqual(
        mockProduct[field]
      );
    });
  }

  it("'Submit' button exists. HINT: Button text should say 'Submit'", () => {
    expect(
      productComponent.containsMatchingElement(<button>Submit</button>)
    ).toBeTruthy();
  });

  it("'Submit' button includes an onClick handler", () => {
    const buttonWrap = productComponent.find("button#submit");
    expect(buttonWrap.props().onClick).toEqual(expect.any(Function));
  });

  it("'Reset' button exists. HINT: Button text should say 'Reset'", () => {
    expect(
      productComponent.containsMatchingElement(<button>Reset</button>)
    ).toBeTruthy();
  });

  it("'Reset' button includes an onClick handler", () => {
    const buttonWrap = productComponent.find("button#reset");
    expect(buttonWrap.props().onClick).toEqual(expect.any(Function));
  });

  it("Reset button should reset form", () => {
    // fill form fields
    const filedsToFill = [
      "name",
      "description",
      "manufacturer",
      "cost",
      "status",
    ];
    for (const field of filedsToFill) {
      const name = productComponent
        .find("#" + field)
        .props()
        .name.trim();
      productComponent.find("#" + field).simulate("change", {
        target: { value: mockProduct[field], name: name },
      });
    }

    const resetButtonWrap = productComponent.find("button#reset");
    resetButtonWrap.simulate("click");

    expect(productComponent.find("#name").props().value).not.toBeTruthy();
    expect(
      productComponent.find("#manufacturer").props().value
    ).not.toBeTruthy();
    expect(
      productComponent.find("#description").props().value
    ).not.toBeTruthy();
    expect(productComponent.find("#cost").props().value).not.toBeTruthy();
    expect(productComponent.find("#status").props().value).not.toBeTruthy();
  });

  it("POST endpoint exists in service file. HINT: Service method should be called 'addProduct'", () => {
    const mockedResponse = {
      data: {},
      config: {},
      headers: {},
      request: "",
      status: 201,
      statusText: "Created",
    };

    axios.post.mockResolvedValue(mockedResponse);
    productService.addProduct();
  });

  it("addProduct in axios service file works correctly", () => {
    const originalProductService = jest.requireActual(
      "../../components/codeChallenge/services/productService"
    );

    originalProductService.default.addProduct(mockProduct);

    expect(axios).toBeCalledWith({
      crossdomain: true,
      data: mockProduct,
      url: "https://api.remotebootcamp.dev/api/entities/products",
      headers: {
        "Content-Type": "application/json",
      },
      withCredentials: true,
      method: "POST",
    });
  });

  it("Submit button calls addProduct in service file", async () => {
    productService.addProduct.mockResolvedValueOnce();
    const buttonWrap = productComponent.find("button#submit");

    await buttonWrap.simulate("click");
    expect(productService.addProduct).toHaveBeenCalledWith(expect.any(Object));
  });

  it("ProductCard should be hidden by default", () => {
    expect(productComponent.find(ProductCard).length).toEqual(0);
  });

  it("ProductCard should be shown if successfully made an axios POST", async () => {
    const mockedResponse = {
      data: {
        item: 1985,
      },
      config: {},
      headers: {},
      request: "",
      status: 201,
      statusText: "Created",
    };

    productService.addProduct.mockResolvedValue(mockedResponse);

    const buttonWrap = productComponent.find("button#submit");

    await act(() => {
      buttonWrap.prop("onClick")();
    });

    productComponent.update();

    expect(productService.addProduct).toHaveBeenCalled();
    expect(productComponent.find(ProductCard)).toHaveLength(1);
  });

  it("If unsuccessfully made an axios POST, should console.log the error", async () => {
    productService.addProduct.mockRejectedValueOnce(new Error());

    jest.spyOn(global.console, "log");

    const buttonWrap = productComponent.find("button#submit");

    await act(() => {
      buttonWrap.simulate("click");
    });

    expect(productService.addProduct).toHaveBeenCalled();
    expect(console.log).toHaveBeenCalledWith(expect.any(Error));
  });

  it("Reset button should hide ProductCard. NOTE: Some previous bugs should also be passed for this one to work.", async () => {
    const mockedResponse = {
      data: {
        item: 1985,
      },
      config: {},
      headers: {},
      request: "",
      status: 201,
      statusText: "Created",
    };

    productService.addProduct.mockResolvedValueOnce(mockedResponse);

    const buttonWrap = productComponent.find("button#submit");
    await act(() => {
      buttonWrap.simulate("click");
    });

    productComponent.update();
    expect(productComponent.find(ProductCard)).toHaveLength(1);

    const resetButtonWrap = productComponent.find("button#reset");
    resetButtonWrap.simulate("click");

    expect(productComponent.find(ProductCard)).toHaveLength(0);
  });

  for (const [key, value] of Object.entries(mockProduct)) {
    it(`ProductCard should display one p tag for '${key}' property of Product.`, () => {
      const productCardWrapper = mount(<ProductCard product={mockProduct} />);

      expect(
        productCardWrapper.findWhere((node) => {
          return node.type() === "p" && node.text().trim() == value;
        })
      ).toHaveLength(1);
    });
  }

  it("When rendered, ProductCard should have a prop of 'product'.", async () => {
    const mockedResponse = {
      data: {
        item: 1985,
      },
      config: {},
      headers: {},
      request: "",
      status: 201,
      statusText: "Created",
    };

    productService.addProduct.mockResolvedValue(mockedResponse);

    const buttonWrap = productComponent.find("button#submit");

    await act(() => {
      buttonWrap.prop("onClick")();
    });

    expect(productService.addProduct).toHaveBeenCalled();

    productComponent.update();

    expect(productComponent.find(ProductCard).prop("product")).toBeTruthy();
  });

  for (const [key] of Object.entries(mockProduct)) {
    it(`When rendered, ProductCard should have a prop of 'product' which should be an object than includes a property of '${key}'. HINT: formData should have empty initial values`, async () => {
      const mockedResponse = {
        data: {
          item: "1985",
        },
        config: {},
        headers: {},
        request: "",
        status: 201,
        statusText: "Created",
      };

      productService.addProduct.mockResolvedValue(mockedResponse);

      const buttonWrap = productComponent.find("button#submit");

      await act(() => {
        buttonWrap.simulate("click");
      });

      expect(productService.addProduct).toHaveBeenCalled();

      productComponent.update();

      expect(productComponent.find(ProductCard).prop("product")[key]).toEqual(
        expect.anything()
      );
    });
  }

  it("The newly created Id should be captured in the success handler of the Ajax call and put into state object", async () => {
    const mockedResponse = {
      data: {
        item: "1985",
      },
      config: {},
      headers: {},
      request: "",
      status: 201,
      statusText: "Created",
    };

    productService.addProduct.mockResolvedValue(mockedResponse);

    const buttonWrap = productComponent.find("button#submit");

    await act(() => {
      buttonWrap.simulate("click");
    });

    expect(productService.addProduct).toHaveBeenCalled();

    productComponent.update();

    expect(productComponent.find(ProductCard).prop("product").id).toEqual(
      mockedResponse.data.item
    );
  });

  const propsToCheck = [
    "name",
    "description",
    "manufacturer",
    "cost",
    "status",
  ];
  for (const propName of propsToCheck) {
    it(`The newly created Product's ${propName} should be passed into ProductCard`, async () => {
      // fill form field
      const name = productComponent
        .find("#" + propName)
        .props()
        .name.trim();
      productComponent.find("#" + propName).simulate("change", {
        target: { value: mockProduct[propName], name: name },
      });

      const mockedResponse = {
        data: {
          item: "1985",
        },
        config: {},
        headers: {},
        request: "",
        status: 201,
        statusText: "Created",
      };

      productService.addProduct.mockResolvedValue(mockedResponse);

      const buttonWrap = productComponent.find("button#submit");

      await act(() => {
        buttonWrap.simulate("click");
      });

      expect(productService.addProduct).toHaveBeenCalled();

      productComponent.update();

      expect(
        productComponent.find(ProductCard).prop("product")[propName]
      ).toEqual(mockProduct[propName]);
    });
  }
});
