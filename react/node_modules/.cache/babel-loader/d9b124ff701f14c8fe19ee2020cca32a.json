{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar identifierUtils = require(\"../util/identifier\");\nvar _require = require(\"../util/SetHelpers\"),\n  intersect = _require.intersect;\nvar validateOptions = require(\"schema-utils\");\nvar schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nvar moveModuleBetween = function moveModuleBetween(oldChunk, newChunk) {\n  return function (module) {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\nvar isNotAEntryModule = function isNotAEntryModule(entryModule) {\n  return function (module) {\n    return entryModule !== module;\n  };\n};\nvar AggressiveSplittingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  function AggressiveSplittingPlugin(options) {\n    _classCallCheck(this, AggressiveSplittingPlugin);\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  _createClass(AggressiveSplittingPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", function (compilation) {\n        var needAdditionalSeal = false;\n        var newSplits;\n        var fromAggressiveSplittingSet;\n        var chunkSplitDataMap;\n        compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", function () {\n          newSplits = [];\n          fromAggressiveSplittingSet = new Set();\n          chunkSplitDataMap = new Map();\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", function (chunks) {\n          // Precompute stuff\n          var nameToModuleMap = new Map();\n          var moduleToNameMap = new Map();\n          var _iterator = _createForOfIteratorHelper(compilation.modules),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var m = _step.value;\n              var name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n              nameToModuleMap.set(name, m);\n              moduleToNameMap.set(m, name);\n            }\n\n            // Check used chunk ids\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var usedIds = new Set();\n          var _iterator2 = _createForOfIteratorHelper(chunks),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var chunk = _step2.value;\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n          var usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n          var minSize = _this.options.minSize;\n          var maxSize = _this.options.maxSize;\n          var applySplit = function applySplit(splitData) {\n            // Cannot split if id is already taken\n            if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n              return false;\n            }\n\n            // Get module objects from names\n            var selectedModules = splitData.modules.map(function (name) {\n              return nameToModuleMap.get(name);\n            });\n\n            // Does the modules exist at all?\n            if (!selectedModules.every(Boolean)) return false;\n\n            // Check if size matches (faster than waiting for hash)\n            var size = selectedModules.reduce(function (sum, m) {\n              return sum + m.size();\n            }, 0);\n            if (size !== splitData.size) return false;\n\n            // get chunks with all modules\n            var selectedChunks = intersect(selectedModules.map(function (m) {\n              return new Set(m.chunksIterable);\n            }));\n\n            // No relevant chunks found\n            if (selectedChunks.size === 0) return false;\n\n            // The found chunk is already the split or similar\n            if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n              var chunk = Array.from(selectedChunks)[0];\n              if (fromAggressiveSplittingSet.has(chunk)) return false;\n              fromAggressiveSplittingSet.add(chunk);\n              chunkSplitDataMap.set(chunk, splitData);\n              return true;\n            }\n\n            // split the chunk into two parts\n            var newChunk = compilation.addChunk();\n            newChunk.chunkReason = \"aggressive splitted\";\n            var _iterator3 = _createForOfIteratorHelper(selectedChunks),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _chunk = _step3.value;\n                selectedModules.forEach(moveModuleBetween(_chunk, newChunk));\n                _chunk.split(newChunk);\n                _chunk.name = null;\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            fromAggressiveSplittingSet.add(newChunk);\n            chunkSplitDataMap.set(newChunk, splitData);\n            if (splitData.id !== null && splitData.id !== undefined) {\n              newChunk.id = splitData.id;\n            }\n            return true;\n          };\n\n          // try to restore to recorded splitting\n          var changed = false;\n          for (var j = 0; j < usedSplits.length; j++) {\n            var splitData = usedSplits[j];\n            if (applySplit(splitData)) changed = true;\n          }\n\n          // for any chunk which isn't splitted yet, split it and create a new entry\n          // start with the biggest chunk\n          var sortedChunks = chunks.slice().sort(function (a, b) {\n            var diff1 = b.modulesSize() - a.modulesSize();\n            if (diff1) return diff1;\n            var diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n            if (diff2) return diff2;\n            var modulesA = Array.from(a.modulesIterable);\n            var modulesB = Array.from(b.modulesIterable);\n            modulesA.sort();\n            modulesB.sort();\n            var aI = modulesA[Symbol.iterator]();\n            var bI = modulesB[Symbol.iterator]();\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n              var aItem = aI.next();\n              var bItem = bI.next();\n              if (aItem.done) return 0;\n              var aModuleIdentifier = aItem.value.identifier();\n              var bModuleIdentifier = bItem.value.identifier();\n              if (aModuleIdentifier > bModuleIdentifier) return -1;\n              if (aModuleIdentifier < bModuleIdentifier) return 1;\n            }\n          });\n          var _iterator4 = _createForOfIteratorHelper(sortedChunks),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _chunk2 = _step4.value;\n              if (fromAggressiveSplittingSet.has(_chunk2)) continue;\n              var size = _chunk2.modulesSize();\n              if (size > maxSize && _chunk2.getNumberOfModules() > 1) {\n                var modules = _chunk2.getModules().filter(isNotAEntryModule(_chunk2.entryModule)).sort(function (a, b) {\n                  a = a.identifier();\n                  b = b.identifier();\n                  if (a > b) return 1;\n                  if (a < b) return -1;\n                  return 0;\n                });\n                var selectedModules = [];\n                var selectedModulesSize = 0;\n                for (var k = 0; k < modules.length; k++) {\n                  var _module = modules[k];\n                  var newSize = selectedModulesSize + _module.size();\n                  if (newSize > maxSize && selectedModulesSize >= minSize) {\n                    break;\n                  }\n                  selectedModulesSize = newSize;\n                  selectedModules.push(_module);\n                }\n                if (selectedModules.length === 0) continue;\n                var _splitData = {\n                  modules: selectedModules.map(function (m) {\n                    return moduleToNameMap.get(m);\n                  }).sort(),\n                  size: selectedModulesSize\n                };\n                if (applySplit(_splitData)) {\n                  newSplits = (newSplits || []).concat(_splitData);\n                  changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          if (changed) return true;\n        });\n        compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", function (records) {\n          // 4. save made splittings to records\n          var allSplits = new Set();\n          var invalidSplits = new Set();\n\n          // Check if some splittings are invalid\n          // We remove invalid splittings and try again\n          var _iterator5 = _createForOfIteratorHelper(compilation.chunks),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _chunk3 = _step5.value;\n              var _splitData3 = chunkSplitDataMap.get(_chunk3);\n              if (_splitData3 !== undefined) {\n                if (_splitData3.hash && _chunk3.hash !== _splitData3.hash) {\n                  // Split was successful, but hash doesn't equal\n                  // We can throw away the split since it's useless now\n                  invalidSplits.add(_splitData3);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          if (invalidSplits.size > 0) {\n            records.aggressiveSplits = records.aggressiveSplits.filter(function (splitData) {\n              return !invalidSplits.has(splitData);\n            });\n            needAdditionalSeal = true;\n          } else {\n            // set hash and id values on all (new) splittings\n            var _iterator6 = _createForOfIteratorHelper(compilation.chunks),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var chunk = _step6.value;\n                var _splitData2 = chunkSplitDataMap.get(chunk);\n                if (_splitData2 !== undefined) {\n                  _splitData2.hash = chunk.hash;\n                  _splitData2.id = chunk.id;\n                  allSplits.add(_splitData2);\n                  // set flag for stats\n                  chunk.recorded = true;\n                }\n              }\n\n              // Also add all unused historial splits (after the used ones)\n              // They can still be used in some future compilation\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n            var recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n            if (recordedSplits) {\n              var _iterator7 = _createForOfIteratorHelper(recordedSplits),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var splitData = _step7.value;\n                  if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n\n            // record all splits\n            records.aggressiveSplits = Array.from(allSplits);\n            needAdditionalSeal = false;\n          }\n        });\n        compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", function () {\n          if (needAdditionalSeal) {\n            needAdditionalSeal = false;\n            return true;\n          }\n        });\n      });\n    }\n  }]);\n  return AggressiveSplittingPlugin;\n}();\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["identifierUtils","require","intersect","validateOptions","schema","moveModuleBetween","oldChunk","newChunk","module","moveModule","isNotAEntryModule","entryModule","AggressiveSplittingPlugin","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunksAdvanced","chunks","nameToModuleMap","moduleToNameMap","modules","m","name","makePathsRelative","context","identifier","cache","set","usedIds","chunk","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","reduce","sum","selectedChunks","chunksIterable","Array","from","getNumberOfModules","length","addChunk","chunkReason","forEach","split","changed","j","sortedChunks","slice","sort","a","b","diff1","modulesSize","diff2","modulesA","modulesIterable","modulesB","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","getModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","recorded","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n\treturn module => {\n\t\toldChunk.moveModule(module, newChunk);\n\t};\n};\n\nconst isNotAEntryModule = entryModule => {\n\treturn module => {\n\t\treturn entryModule !== module;\n\t};\n};\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Aggressive Splitting Plugin\");\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tm.identifier(),\n\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tconst size = selectedModules.reduce(\n\t\t\t\t\t\t\t\t(sum, m) => sum + m.size(),\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(m => new Set(m.chunksIterable))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0].getNumberOfModules() ===\n\t\t\t\t\t\t\t\t\tselectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(moveModuleBetween(chunk, newChunk));\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst sortedChunks = chunks.slice().sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 = b.modulesSize() - a.modulesSize();\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\tconst modulesA = Array.from(a.modulesIterable);\n\t\t\t\t\t\t\tconst modulesB = Array.from(b.modulesIterable);\n\t\t\t\t\t\t\tmodulesA.sort();\n\t\t\t\t\t\t\tmodulesB.sort();\n\t\t\t\t\t\t\tconst aI = modulesA[Symbol.iterator]();\n\t\t\t\t\t\t\tconst bI = modulesB[Symbol.iterator]();\n\t\t\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst aItem = aI.next();\n\t\t\t\t\t\t\t\tconst bItem = bI.next();\n\t\t\t\t\t\t\t\tif (aItem.done) return 0;\n\t\t\t\t\t\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\t\t\t\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\t\t\t\t\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\t\t\t\t\t\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunk.modulesSize();\n\t\t\t\t\t\t\tif (size > maxSize && chunk.getNumberOfModules() > 1) {\n\t\t\t\t\t\t\t\tconst modules = chunk\n\t\t\t\t\t\t\t\t\t.getModules()\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunk.entryModule))\n\t\t\t\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t\t\t\ta = a.identifier();\n\t\t\t\t\t\t\t\t\t\tb = b.identifier();\n\t\t\t\t\t\t\t\t\t\tif (a > b) return 1;\n\t\t\t\t\t\t\t\t\t\tif (a < b) return -1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\tchunk.recorded = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historial splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}