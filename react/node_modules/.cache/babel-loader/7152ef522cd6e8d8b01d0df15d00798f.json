{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n *\n */\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Generator = /*#__PURE__*/function () {\n  function Generator() {\n    _classCallCheck(this, Generator);\n  }\n  _createClass(Generator, [{\n    key: \"generate\",\n    value:\n    /**\n     * @abstract\n     * @param {NormalModule} module module for which the code should be generated\n     * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n     * @param {RuntimeTemplate} runtimeTemplate the runtime template\n     * @param {string} type which kind of code should be generated\n     * @returns {Source} generated code\n     */\n    function generate(module, dependencyTemplates, runtimeTemplate, type) {\n      throw new Error(\"Generator.generate: must be overridden\");\n    }\n  }], [{\n    key: \"byType\",\n    value: function byType(map) {\n      return new ByTypeGenerator(map);\n    }\n  }]);\n  return Generator;\n}();\nvar ByTypeGenerator = /*#__PURE__*/function (_Generator) {\n  _inherits(ByTypeGenerator, _Generator);\n  var _super = _createSuper(ByTypeGenerator);\n  function ByTypeGenerator(map) {\n    var _this;\n    _classCallCheck(this, ByTypeGenerator);\n    _this = _super.call(this);\n    _this.map = map;\n    return _this;\n  }\n\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n  _createClass(ByTypeGenerator, [{\n    key: \"generate\",\n    value: function generate(module, dependencyTemplates, runtimeTemplate, type) {\n      var generator = this.map[type];\n      if (!generator) {\n        throw new Error(\"Generator.byType: no generator specified for \".concat(type));\n      }\n      return generator.generate(module, dependencyTemplates, runtimeTemplate, type);\n    }\n  }]);\n  return ByTypeGenerator;\n}(Generator);\nmodule.exports = Generator;","map":{"version":3,"names":["Generator","module","dependencyTemplates","runtimeTemplate","type","Error","map","ByTypeGenerator","generator","generate","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/Generator.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n *\n */\nclass Generator {\n\tstatic byType(map) {\n\t\treturn new ByTypeGenerator(map);\n\t}\n\n\t/**\n\t * @abstract\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n\t * @param {RuntimeTemplate} runtimeTemplate the runtime template\n\t * @param {string} type which kind of code should be generated\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, dependencyTemplates, runtimeTemplate, type) {\n\t\tthrow new Error(\"Generator.generate: must be overridden\");\n\t}\n}\n\nclass ByTypeGenerator extends Generator {\n\tconstructor(map) {\n\t\tsuper();\n\t\tthis.map = map;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n\t * @param {RuntimeTemplate} runtimeTemplate the runtime template\n\t * @param {string} type which kind of code should be generated\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, dependencyTemplates, runtimeTemplate, type) {\n\t\tconst generator = this.map[type];\n\t\tif (!generator) {\n\t\t\tthrow new Error(`Generator.byType: no generator specified for ${type}`);\n\t\t}\n\t\treturn generator.generate(\n\t\t\tmodule,\n\t\t\tdependencyTemplates,\n\t\t\truntimeTemplate,\n\t\t\ttype\n\t\t);\n\t}\n}\n\nmodule.exports = Generator;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA,IAGMA,SAAS;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IAKd;AACD;AACA;AACA;AACA;AACA;AACA;AACA;IACC,kBAASC,MAAM,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,IAAI,EAAE;MAC5D,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;IAC1D;EAAC;IAAA;IAAA,OAdD,gBAAcC,GAAG,EAAE;MAClB,OAAO,IAAIC,eAAe,CAACD,GAAG,CAAC;IAChC;EAAC;EAAA;AAAA;AAAA,IAeIC,eAAe;EAAA;EAAA;EACpB,yBAAYD,GAAG,EAAE;IAAA;IAAA;IAChB;IACA,MAAKA,GAAG,GAAGA,GAAG;IAAC;EAChB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EANC;IAAA;IAAA,OAOA,kBAASL,MAAM,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,IAAI,EAAE;MAC5D,IAAMI,SAAS,GAAG,IAAI,CAACF,GAAG,CAACF,IAAI,CAAC;MAChC,IAAI,CAACI,SAAS,EAAE;QACf,MAAM,IAAIH,KAAK,wDAAiDD,IAAI,EAAG;MACxE;MACA,OAAOI,SAAS,CAACC,QAAQ,CACxBR,MAAM,EACNC,mBAAmB,EACnBC,eAAe,EACfC,IAAI,CACJ;IACF;EAAC;EAAA;AAAA,EAxB4BJ,SAAS;AA2BvCC,MAAM,CAACS,OAAO,GAAGV,SAAS"},"metadata":{},"sourceType":"script"}