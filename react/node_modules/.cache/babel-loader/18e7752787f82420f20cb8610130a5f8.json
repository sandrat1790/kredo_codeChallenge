{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\n\"use strict\";\n\n/**\n * @param {any[]} args items to be truncated\n * @param {number} maxLength maximum length of args including spaces between\n * @returns {string[]} truncated args\n */\nvar _toConsumableArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar truncateArgs = function truncateArgs(args, maxLength) {\n  var lengths = args.map(function (a) {\n    return \"\".concat(a).length;\n  });\n  var availableLength = maxLength - lengths.length + 1;\n  if (availableLength > 0 && args.length === 1) {\n    if (availableLength >= args[0].length) {\n      return args;\n    } else if (availableLength > 3) {\n      return [\"...\" + args[0].slice(-availableLength + 3)];\n    } else {\n      return [args[0].slice(-availableLength)];\n    }\n  }\n\n  // Check if there is space for at least 4 chars per arg\n  if (availableLength < lengths.reduce(function (s, i) {\n    return s + Math.min(i, 6);\n  }, 0)) {\n    // remove args\n    if (args.length > 1) return truncateArgs(args.slice(0, args.length - 1), maxLength);\n    return [];\n  }\n  var currentLength = lengths.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n\n  // Check if all fits into maxLength\n  if (currentLength <= availableLength) return args;\n\n  // Try to remove chars from the longest items until it fits\n  var _loop = function _loop() {\n    var maxLength = Math.max.apply(Math, _toConsumableArray(lengths));\n    var shorterItems = lengths.filter(function (l) {\n      return l !== maxLength;\n    });\n    var nextToMaxLength = shorterItems.length > 0 ? Math.max.apply(Math, _toConsumableArray(shorterItems)) : 0;\n    var maxReduce = maxLength - nextToMaxLength;\n    var maxItems = lengths.length - shorterItems.length;\n    var overrun = currentLength - availableLength;\n    for (var i = 0; i < lengths.length; i++) {\n      if (lengths[i] === maxLength) {\n        var reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n        lengths[i] -= reduce;\n        currentLength -= reduce;\n        overrun -= reduce;\n        maxItems--;\n      }\n    }\n  };\n  while (currentLength > availableLength) {\n    _loop();\n  }\n\n  // Return args reduced to length in lengths\n  return args.map(function (a, i) {\n    var str = \"\".concat(a);\n    var length = lengths[i];\n    if (str.length === length) {\n      return str;\n    } else if (length > 5) {\n      return \"...\" + str.slice(-length + 3);\n    } else if (length > 0) {\n      return str.slice(-length);\n    } else {\n      return \"\";\n    }\n  });\n};\nmodule.exports = truncateArgs;","map":{"version":3,"names":["truncateArgs","args","maxLength","lengths","map","a","length","availableLength","slice","reduce","s","i","Math","min","currentLength","b","max","shorterItems","filter","l","nextToMaxLength","maxReduce","maxItems","overrun","floor","str","module","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/logging/truncateArgs.js"],"sourcesContent":["/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\n\"use strict\";\n\n/**\n * @param {any[]} args items to be truncated\n * @param {number} maxLength maximum length of args including spaces between\n * @returns {string[]} truncated args\n */\nconst truncateArgs = (args, maxLength) => {\n\tconst lengths = args.map(a => `${a}`.length);\n\tconst availableLength = maxLength - lengths.length + 1;\n\n\tif (availableLength > 0 && args.length === 1) {\n\t\tif (availableLength >= args[0].length) {\n\t\t\treturn args;\n\t\t} else if (availableLength > 3) {\n\t\t\treturn [\"...\" + args[0].slice(-availableLength + 3)];\n\t\t} else {\n\t\t\treturn [args[0].slice(-availableLength)];\n\t\t}\n\t}\n\n\t// Check if there is space for at least 4 chars per arg\n\tif (availableLength < lengths.reduce((s, i) => s + Math.min(i, 6), 0)) {\n\t\t// remove args\n\t\tif (args.length > 1)\n\t\t\treturn truncateArgs(args.slice(0, args.length - 1), maxLength);\n\t\treturn [];\n\t}\n\n\tlet currentLength = lengths.reduce((a, b) => a + b, 0);\n\n\t// Check if all fits into maxLength\n\tif (currentLength <= availableLength) return args;\n\n\t// Try to remove chars from the longest items until it fits\n\twhile (currentLength > availableLength) {\n\t\tconst maxLength = Math.max(...lengths);\n\t\tconst shorterItems = lengths.filter(l => l !== maxLength);\n\t\tconst nextToMaxLength =\n\t\t\tshorterItems.length > 0 ? Math.max(...shorterItems) : 0;\n\t\tconst maxReduce = maxLength - nextToMaxLength;\n\t\tlet maxItems = lengths.length - shorterItems.length;\n\t\tlet overrun = currentLength - availableLength;\n\t\tfor (let i = 0; i < lengths.length; i++) {\n\t\t\tif (lengths[i] === maxLength) {\n\t\t\t\tconst reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n\t\t\t\tlengths[i] -= reduce;\n\t\t\t\tcurrentLength -= reduce;\n\t\t\t\toverrun -= reduce;\n\t\t\t\tmaxItems--;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return args reduced to length in lengths\n\treturn args.map((a, i) => {\n\t\tconst str = `${a}`;\n\t\tconst length = lengths[i];\n\t\tif (str.length === length) {\n\t\t\treturn str;\n\t\t} else if (length > 5) {\n\t\t\treturn \"...\" + str.slice(-length + 3);\n\t\t} else if (length > 0) {\n\t\t\treturn str.slice(-length);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t});\n};\n\nmodule.exports = truncateArgs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}