{"ast":null,"code":"\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar similarity = function similarity(a, b) {\n  var l = Math.min(a.length, b.length);\n  var dist = 0;\n  for (var i = 0; i < l; i++) {\n    var ca = a.charCodeAt(i);\n    var cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n  return dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nvar getName = function getName(a, b) {\n  var l = Math.min(a.length, b.length);\n  var r = \"\";\n  for (var i = 0; i < l; i++) {\n    var ca = a.charAt(i);\n    var cb = b.charAt(i);\n    r += ca;\n    if (ca === cb) {\n      continue;\n    }\n    return r;\n  }\n  return a;\n};\n\n/**\n * @template T\n */\nvar Node = /*#__PURE__*/_createClass(\n/**\n * @param {T} item item\n * @param {string} key key\n * @param {number} size size\n */\nfunction Node(item, key, size) {\n  _classCallCheck(this, Node);\n  this.item = item;\n  this.key = key;\n  this.size = size;\n});\n/**\n * @template T\n */\nvar Group = /*#__PURE__*/_createClass(\n/**\n * @param {Node<T>[]} nodes nodes\n * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n */\nfunction Group(nodes, similarities) {\n  _classCallCheck(this, Group);\n  this.nodes = nodes;\n  this.similarities = similarities;\n  this.size = nodes.reduce(function (size, node) {\n    return size + node.size;\n  }, 0);\n  /** @type {string} */\n  this.key = undefined;\n});\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = function (_ref) {\n  var maxSize = _ref.maxSize,\n    minSize = _ref.minSize,\n    items = _ref.items,\n    getSize = _ref.getSize,\n    getKey = _ref.getKey;\n  /** @type {Group<T>[]} */\n  var result = [];\n  var nodes = Array.from(items, function (item) {\n    return new Node(item, getKey(item), getSize(item));\n  });\n\n  /** @type {Node<T>[]} */\n  var initialNodes = [];\n\n  // lexically ordering of keys\n  nodes.sort(function (a, b) {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n\n  // return nodes bigger than maxSize directly as group\n  for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {\n    var node = _nodes[_i];\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n    /** @type {number[]} */\n    var similarities = [];\n    for (var i = 1; i < initialNodes.length; i++) {\n      var a = initialNodes[i - 1];\n      var b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n    var initialGroup = new Group(initialNodes, similarities);\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        var smallestGroup = result.reduce(function (min, group) {\n          return min.size > group.size ? group : min;\n        });\n        var _iterator = _createForOfIteratorHelper(initialGroup.nodes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _node = _step.value;\n            smallestGroup.nodes.push(_node);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        smallestGroup.nodes.sort(function (a, b) {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      var queue = [initialGroup];\n      while (queue.length) {\n        var group = queue.pop();\n        // only groups bigger than maxSize need to be splitted\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        }\n\n        // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n        var left = 0;\n        var leftSize = 0;\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n        var right = group.nodes.length - 1;\n        var rightSize = 0;\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          var best = left - 1;\n          var bestSimilarity = group.similarities[best];\n          for (var _i2 = left; _i2 <= right; _i2++) {\n            var _similarity = group.similarities[_i2];\n            if (_similarity < bestSimilarity) {\n              best = _i2;\n              bestSimilarity = _similarity;\n            }\n          }\n          left = best + 1;\n          right = best;\n        }\n\n        // create two new groups for left and right area\n        // and queue them up\n        var rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n        var rightSimilaries = [];\n        for (var _i3 = right + 2; _i3 < group.nodes.length; _i3++) {\n          rightSimilaries.push(group.similarities[_i3 - 1]);\n          rightNodes.push(group.nodes[_i3]);\n        }\n        queue.push(new Group(rightNodes, rightSimilaries));\n        var leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n        var leftSimilaries = [];\n        for (var _i4 = 1; _i4 < left; _i4++) {\n          leftSimilaries.push(group.similarities[_i4 - 1]);\n          leftNodes.push(group.nodes[_i4]);\n        }\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  }\n\n  // lexically ordering\n  result.sort(function (a, b) {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  });\n\n  // give every group a name\n  for (var _i5 = 0; _i5 < result.length; _i5++) {\n    var _group = result[_i5];\n    var first = _group.nodes[0];\n    var last = _group.nodes[_group.nodes.length - 1];\n    var name = getName(first.key, last.key);\n    _group.key = name;\n  }\n\n  // return the results\n  return result.map(function (group) {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(function (node) {\n        return node.item;\n      }),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","r","charAt","Node","item","key","size","Group","nodes","similarities","reduce","node","undefined","module","exports","maxSize","minSize","items","getSize","getKey","result","Array","from","initialNodes","sort","push","initialGroup","smallestGroup","group","queue","pop","left","leftSize","right","rightSize","best","bestSimilarity","rightNodes","rightSimilaries","leftNodes","leftSimilaries","first","last","name","map"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet r = \"\";\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charAt(i);\n\t\tconst cb = b.charAt(i);\n\t\tr += ca;\n\t\tif (ca === cb) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r;\n\t}\n\treturn a;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {number} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t */\n\tconstructor(nodes, similarities) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = nodes.reduce((size, node) => size + node.size, 0);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\tfor (const node of nodes) {\n\t\tif (node.size >= maxSize) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\t// calculate similarities between lexically adjacent nodes\n\t\t/** @type {number[]} */\n\t\tconst similarities = [];\n\t\tfor (let i = 1; i < initialNodes.length; i++) {\n\t\t\tconst a = initialNodes[i - 1];\n\t\t\tconst b = initialNodes[i];\n\t\t\tsimilarities.push(similarity(a.key, b.key));\n\t\t}\n\n\t\tconst initialGroup = new Group(initialNodes, similarities);\n\n\t\tif (initialGroup.size < minSize) {\n\t\t\t// We hit an edgecase where the working set is already smaller than minSize\n\t\t\t// We merge it with the smallest result node to keep minSize intact\n\t\t\tif (result.length > 0) {\n\t\t\t\tconst smallestGroup = result.reduce((min, group) =>\n\t\t\t\t\tmin.size > group.size ? group : min\n\t\t\t\t);\n\t\t\t\tfor (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\t\t\t\tsmallestGroup.nodes.sort((a, b) => {\n\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// There are no other nodes\n\t\t\t\t// We use all nodes and have to accept that it's smaller than minSize\n\t\t\t\tresult.push(initialGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (group.size < maxSize) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 0;\n\t\t\t\tlet leftSize = 0;\n\t\t\t\twhile (leftSize <= minSize) {\n\t\t\t\t\tleftSize += group.nodes[left].size;\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 1;\n\t\t\t\tlet rightSize = 0;\n\t\t\t\twhile (rightSize <= minSize) {\n\t\t\t\t\trightSize += group.nodes[right].size;\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the group here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\tlet best = left - 1;\n\t\t\t\t\tlet bestSimilarity = group.similarities[best];\n\t\t\t\t\tfor (let i = left; i <= right; i++) {\n\t\t\t\t\t\tconst similarity = group.similarities[i];\n\t\t\t\t\t\tif (similarity < bestSimilarity) {\n\t\t\t\t\t\t\tbest = i;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft = best + 1;\n\t\t\t\t\tright = best;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilaries = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilaries));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilaries = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilaries));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tconst first = group.nodes[0];\n\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\tlet name = getName(first.key, last.key);\n\t\tgroup.key = name;\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAMA,IAAMA,UAAU,GAAG,SAAbA,UAAU,CAAIC,CAAC,EAAEC,CAAC,EAAK;EAC5B,IAAMC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACJ,CAAC,CAACK,MAAM,EAAEJ,CAAC,CAACI,MAAM,CAAC;EACtC,IAAIC,IAAI,GAAG,CAAC;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;IAC3B,IAAMC,EAAE,GAAGR,CAAC,CAACS,UAAU,CAACF,CAAC,CAAC;IAC1B,IAAMG,EAAE,GAAGT,CAAC,CAACQ,UAAU,CAACF,CAAC,CAAC;IAC1BD,IAAI,IAAIH,IAAI,CAACQ,GAAG,CAAC,CAAC,EAAE,EAAE,GAAGR,IAAI,CAACS,GAAG,CAACJ,EAAE,GAAGE,EAAE,CAAC,CAAC;EAC5C;EACA,OAAOJ,IAAI;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAMO,OAAO,GAAG,SAAVA,OAAO,CAAIb,CAAC,EAAEC,CAAC,EAAK;EACzB,IAAMC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACJ,CAAC,CAACK,MAAM,EAAEJ,CAAC,CAACI,MAAM,CAAC;EACtC,IAAIS,CAAC,GAAG,EAAE;EACV,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;IAC3B,IAAMC,EAAE,GAAGR,CAAC,CAACe,MAAM,CAACR,CAAC,CAAC;IACtB,IAAMG,EAAE,GAAGT,CAAC,CAACc,MAAM,CAACR,CAAC,CAAC;IACtBO,CAAC,IAAIN,EAAE;IACP,IAAIA,EAAE,KAAKE,EAAE,EAAE;MACd;IACD;IACA,OAAOI,CAAC;EACT;EACA,OAAOd,CAAC;AACT,CAAC;;AAED;AACA;AACA;AAFA,IAGMgB,IAAI;AACT;AACD;AACA;AACA;AACA;AACC,cAAYC,IAAI,EAAEC,GAAG,EAAEC,IAAI,EAAE;EAAA;EAC5B,IAAI,CAACF,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACC,GAAG,GAAGA,GAAG;EACd,IAAI,CAACC,IAAI,GAAGA,IAAI;AACjB,CAAC;AAGF;AACA;AACA;AAFA,IAGMC,KAAK;AACV;AACD;AACA;AACA;AACC,eAAYC,KAAK,EAAEC,YAAY,EAAE;EAAA;EAChC,IAAI,CAACD,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,YAAY,GAAGA,YAAY;EAChC,IAAI,CAACH,IAAI,GAAGE,KAAK,CAACE,MAAM,CAAC,UAACJ,IAAI,EAAEK,IAAI;IAAA,OAAKL,IAAI,GAAGK,IAAI,CAACL,IAAI;EAAA,GAAE,CAAC,CAAC;EAC7D;EACA,IAAI,CAACD,GAAG,GAAGO,SAAS;AACrB,CAAC;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,gBAAkD;EAAA,IAA/CC,OAAO,QAAPA,OAAO;IAAEC,OAAO,QAAPA,OAAO;IAAEC,KAAK,QAALA,KAAK;IAAEC,OAAO,QAAPA,OAAO;IAAEC,MAAM,QAANA,MAAM;EAC3D;EACA,IAAMC,MAAM,GAAG,EAAE;EAEjB,IAAMZ,KAAK,GAAGa,KAAK,CAACC,IAAI,CACvBL,KAAK,EACL,UAAAb,IAAI;IAAA,OAAI,IAAID,IAAI,CAACC,IAAI,EAAEe,MAAM,CAACf,IAAI,CAAC,EAAEc,OAAO,CAACd,IAAI,CAAC,CAAC;EAAA,EACnD;;EAED;EACA,IAAMmB,YAAY,GAAG,EAAE;;EAEvB;EACAf,KAAK,CAACgB,IAAI,CAAC,UAACrC,CAAC,EAAEC,CAAC,EAAK;IACpB,IAAID,CAAC,CAACkB,GAAG,GAAGjB,CAAC,CAACiB,GAAG,EAAE,OAAO,CAAC,CAAC;IAC5B,IAAIlB,CAAC,CAACkB,GAAG,GAAGjB,CAAC,CAACiB,GAAG,EAAE,OAAO,CAAC;IAC3B,OAAO,CAAC;EACT,CAAC,CAAC;;EAEF;EACA,0BAAmBG,KAAK,4BAAE;IAArB,IAAMG,IAAI;IACd,IAAIA,IAAI,CAACL,IAAI,IAAIS,OAAO,EAAE;MACzBK,MAAM,CAACK,IAAI,CAAC,IAAIlB,KAAK,CAAC,CAACI,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;IACnC,CAAC,MAAM;MACNY,YAAY,CAACE,IAAI,CAACd,IAAI,CAAC;IACxB;EACD;EAEA,IAAIY,YAAY,CAAC/B,MAAM,GAAG,CAAC,EAAE;IAC5B;IACA;IACA,IAAMiB,YAAY,GAAG,EAAE;IACvB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,YAAY,CAAC/B,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC7C,IAAMP,CAAC,GAAGoC,YAAY,CAAC7B,CAAC,GAAG,CAAC,CAAC;MAC7B,IAAMN,CAAC,GAAGmC,YAAY,CAAC7B,CAAC,CAAC;MACzBe,YAAY,CAACgB,IAAI,CAACvC,UAAU,CAACC,CAAC,CAACkB,GAAG,EAAEjB,CAAC,CAACiB,GAAG,CAAC,CAAC;IAC5C;IAEA,IAAMqB,YAAY,GAAG,IAAInB,KAAK,CAACgB,YAAY,EAAEd,YAAY,CAAC;IAE1D,IAAIiB,YAAY,CAACpB,IAAI,GAAGU,OAAO,EAAE;MAChC;MACA;MACA,IAAII,MAAM,CAAC5B,MAAM,GAAG,CAAC,EAAE;QACtB,IAAMmC,aAAa,GAAGP,MAAM,CAACV,MAAM,CAAC,UAACnB,GAAG,EAAEqC,KAAK;UAAA,OAC9CrC,GAAG,CAACe,IAAI,GAAGsB,KAAK,CAACtB,IAAI,GAAGsB,KAAK,GAAGrC,GAAG;QAAA,EACnC;QAAC,2CACiBmC,YAAY,CAAClB,KAAK;UAAA;QAAA;UAArC,oDAAuC;YAAA,IAA5BG,KAAI;YAAwBgB,aAAa,CAACnB,KAAK,CAACiB,IAAI,CAACd,KAAI,CAAC;UAAA;QAAC;UAAA;QAAA;UAAA;QAAA;QACtEgB,aAAa,CAACnB,KAAK,CAACgB,IAAI,CAAC,UAACrC,CAAC,EAAEC,CAAC,EAAK;UAClC,IAAID,CAAC,CAACkB,GAAG,GAAGjB,CAAC,CAACiB,GAAG,EAAE,OAAO,CAAC,CAAC;UAC5B,IAAIlB,CAAC,CAACkB,GAAG,GAAGjB,CAAC,CAACiB,GAAG,EAAE,OAAO,CAAC;UAC3B,OAAO,CAAC;QACT,CAAC,CAAC;MACH,CAAC,MAAM;QACN;QACA;QACAe,MAAM,CAACK,IAAI,CAACC,YAAY,CAAC;MAC1B;IACD,CAAC,MAAM;MACN,IAAMG,KAAK,GAAG,CAACH,YAAY,CAAC;MAE5B,OAAOG,KAAK,CAACrC,MAAM,EAAE;QACpB,IAAMoC,KAAK,GAAGC,KAAK,CAACC,GAAG,EAAE;QACzB;QACA,IAAIF,KAAK,CAACtB,IAAI,GAAGS,OAAO,EAAE;UACzBK,MAAM,CAACK,IAAI,CAACG,KAAK,CAAC;UAClB;QACD;;QAEA;QACA;QACA;QACA,IAAIG,IAAI,GAAG,CAAC;QACZ,IAAIC,QAAQ,GAAG,CAAC;QAChB,OAAOA,QAAQ,IAAIhB,OAAO,EAAE;UAC3BgB,QAAQ,IAAIJ,KAAK,CAACpB,KAAK,CAACuB,IAAI,CAAC,CAACzB,IAAI;UAClCyB,IAAI,EAAE;QACP;QACA,IAAIE,KAAK,GAAGL,KAAK,CAACpB,KAAK,CAAChB,MAAM,GAAG,CAAC;QAClC,IAAI0C,SAAS,GAAG,CAAC;QACjB,OAAOA,SAAS,IAAIlB,OAAO,EAAE;UAC5BkB,SAAS,IAAIN,KAAK,CAACpB,KAAK,CAACyB,KAAK,CAAC,CAAC3B,IAAI;UACpC2B,KAAK,EAAE;QACR;QAEA,IAAIF,IAAI,GAAG,CAAC,GAAGE,KAAK,EAAE;UACrB;UACA;UACA;UACA;UACAb,MAAM,CAACK,IAAI,CAACG,KAAK,CAAC;UAClB;QACD;QACA,IAAIG,IAAI,IAAIE,KAAK,EAAE;UAClB;UACA;UACA;UACA;UACA,IAAIE,IAAI,GAAGJ,IAAI,GAAG,CAAC;UACnB,IAAIK,cAAc,GAAGR,KAAK,CAACnB,YAAY,CAAC0B,IAAI,CAAC;UAC7C,KAAK,IAAIzC,GAAC,GAAGqC,IAAI,EAAErC,GAAC,IAAIuC,KAAK,EAAEvC,GAAC,EAAE,EAAE;YACnC,IAAMR,WAAU,GAAG0C,KAAK,CAACnB,YAAY,CAACf,GAAC,CAAC;YACxC,IAAIR,WAAU,GAAGkD,cAAc,EAAE;cAChCD,IAAI,GAAGzC,GAAC;cACR0C,cAAc,GAAGlD,WAAU;YAC5B;UACD;UACA6C,IAAI,GAAGI,IAAI,GAAG,CAAC;UACfF,KAAK,GAAGE,IAAI;QACb;;QAEA;QACA;QACA,IAAME,UAAU,GAAG,CAACT,KAAK,CAACpB,KAAK,CAACyB,KAAK,GAAG,CAAC,CAAC,CAAC;QAC3C;QACA,IAAMK,eAAe,GAAG,EAAE;QAC1B,KAAK,IAAI5C,GAAC,GAAGuC,KAAK,GAAG,CAAC,EAAEvC,GAAC,GAAGkC,KAAK,CAACpB,KAAK,CAAChB,MAAM,EAAEE,GAAC,EAAE,EAAE;UACpD4C,eAAe,CAACb,IAAI,CAACG,KAAK,CAACnB,YAAY,CAACf,GAAC,GAAG,CAAC,CAAC,CAAC;UAC/C2C,UAAU,CAACZ,IAAI,CAACG,KAAK,CAACpB,KAAK,CAACd,GAAC,CAAC,CAAC;QAChC;QACAmC,KAAK,CAACJ,IAAI,CAAC,IAAIlB,KAAK,CAAC8B,UAAU,EAAEC,eAAe,CAAC,CAAC;QAElD,IAAMC,SAAS,GAAG,CAACX,KAAK,CAACpB,KAAK,CAAC,CAAC,CAAC,CAAC;QAClC;QACA,IAAMgC,cAAc,GAAG,EAAE;QACzB,KAAK,IAAI9C,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGqC,IAAI,EAAErC,GAAC,EAAE,EAAE;UAC9B8C,cAAc,CAACf,IAAI,CAACG,KAAK,CAACnB,YAAY,CAACf,GAAC,GAAG,CAAC,CAAC,CAAC;UAC9C6C,SAAS,CAACd,IAAI,CAACG,KAAK,CAACpB,KAAK,CAACd,GAAC,CAAC,CAAC;QAC/B;QACAmC,KAAK,CAACJ,IAAI,CAAC,IAAIlB,KAAK,CAACgC,SAAS,EAAEC,cAAc,CAAC,CAAC;MACjD;IACD;EACD;;EAEA;EACApB,MAAM,CAACI,IAAI,CAAC,UAACrC,CAAC,EAAEC,CAAC,EAAK;IACrB,IAAID,CAAC,CAACqB,KAAK,CAAC,CAAC,CAAC,CAACH,GAAG,GAAGjB,CAAC,CAACoB,KAAK,CAAC,CAAC,CAAC,CAACH,GAAG,EAAE,OAAO,CAAC,CAAC;IAC9C,IAAIlB,CAAC,CAACqB,KAAK,CAAC,CAAC,CAAC,CAACH,GAAG,GAAGjB,CAAC,CAACoB,KAAK,CAAC,CAAC,CAAC,CAACH,GAAG,EAAE,OAAO,CAAC;IAC7C,OAAO,CAAC;EACT,CAAC,CAAC;;EAEF;EACA,KAAK,IAAIX,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG0B,MAAM,CAAC5B,MAAM,EAAEE,GAAC,EAAE,EAAE;IACvC,IAAMkC,MAAK,GAAGR,MAAM,CAAC1B,GAAC,CAAC;IACvB,IAAM+C,KAAK,GAAGb,MAAK,CAACpB,KAAK,CAAC,CAAC,CAAC;IAC5B,IAAMkC,IAAI,GAAGd,MAAK,CAACpB,KAAK,CAACoB,MAAK,CAACpB,KAAK,CAAChB,MAAM,GAAG,CAAC,CAAC;IAChD,IAAImD,IAAI,GAAG3C,OAAO,CAACyC,KAAK,CAACpC,GAAG,EAAEqC,IAAI,CAACrC,GAAG,CAAC;IACvCuB,MAAK,CAACvB,GAAG,GAAGsC,IAAI;EACjB;;EAEA;EACA,OAAOvB,MAAM,CAACwB,GAAG,CAAC,UAAAhB,KAAK,EAAI;IAC1B;IACA,OAAO;MACNvB,GAAG,EAAEuB,KAAK,CAACvB,GAAG;MACdY,KAAK,EAAEW,KAAK,CAACpB,KAAK,CAACoC,GAAG,CAAC,UAAAjC,IAAI;QAAA,OAAIA,IAAI,CAACP,IAAI;MAAA,EAAC;MACzCE,IAAI,EAAEsB,KAAK,CAACtB;IACb,CAAC;EACF,CAAC,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script"}