{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\nvar Replacement = /*#__PURE__*/_createClass(function Replacement(start, end, content, insertIndex, name) {\n  _classCallCheck(this, Replacement);\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.insertIndex = insertIndex;\n  this.name = name;\n});\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n  var _super = _createSuper(ReplaceSource);\n  function ReplaceSource(source, name) {\n    var _this;\n    _classCallCheck(this, ReplaceSource);\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n    _this.replacements = [];\n    return _this;\n  }\n  _createClass(ReplaceSource, [{\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n      this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n      this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n    }\n  }, {\n    key: \"source\",\n    value: function source(options) {\n      return this._replaceString(this._source.source());\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      this.replacements.sort(function (a, b) {\n        var diff = b.end - a.end;\n        if (diff !== 0) return diff;\n        diff = b.start - a.start;\n        if (diff !== 0) return diff;\n        return b.insertIndex - a.insertIndex;\n      });\n    }\n  }, {\n    key: \"_replaceString\",\n    value: function _replaceString(str) {\n      if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n      this._sortReplacements();\n      var result = [str];\n      this.replacements.forEach(function (repl) {\n        var remSource = result.pop();\n        var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n        var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n        result.push(splitted1[1], repl.content, splitted2[0]);\n      }, this);\n\n      // write out result array in reverse order\n      var resultStr = \"\";\n      for (var i = result.length - 1; i >= 0; --i) {\n        resultStr += result[i];\n      }\n      return resultStr;\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n      if (this.replacements.length === 0) {\n        return node;\n      }\n      this._sortReplacements();\n      var replace = new ReplacementEnumerator(this.replacements);\n      var output = [];\n      var position = 0;\n      var sources = Object.create(null);\n      var sourcesInLines = Object.create(null);\n\n      // We build a new list of SourceNodes in \"output\"\n      // from the original mapping data\n\n      var result = new SourceNode();\n\n      // We need to add source contents manually\n      // because \"walk\" will not handle it\n      node.walkSourceContents(function (sourceFile, sourceContent) {\n        result.setSourceContent(sourceFile, sourceContent);\n        sources[\"$\" + sourceFile] = sourceContent;\n      });\n      var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n        var key = \"$\" + mapping.source;\n        var lines = sourcesInLines[key];\n        if (!lines) {\n          var source = sources[key];\n          if (!source) return null;\n          lines = source.split(\"\\n\").map(function (line) {\n            return line + \"\\n\";\n          });\n          sourcesInLines[key] = lines;\n        }\n        // line is 1-based\n        if (mapping.line > lines.length) return null;\n        var line = lines[mapping.line - 1];\n        return line.substr(mapping.column);\n      });\n      node.walk(function (chunk, mapping) {\n        position = replaceInStringNode(chunk, position, mapping);\n      });\n\n      // If any replacements occur after the end of the original file, then we append them\n      // directly to the end of the output\n      var remaining = replace.footer();\n      if (remaining) {\n        output.push(remaining);\n      }\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      this._sortReplacements();\n      var map = this._source.listMap(options);\n      var currentIndex = 0;\n      var replacements = this.replacements;\n      var idxReplacement = replacements.length - 1;\n      var removeChars = 0;\n      map = map.mapGeneratedCode(function (str) {\n        var newCurrentIndex = currentIndex + str.length;\n        if (removeChars > str.length) {\n          removeChars -= str.length;\n          str = \"\";\n        } else {\n          if (removeChars > 0) {\n            str = str.substr(removeChars);\n            currentIndex += removeChars;\n            removeChars = 0;\n          }\n          var finalStr = \"\";\n          while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n            var repl = replacements[idxReplacement];\n            var start = Math.floor(repl.start);\n            var end = Math.floor(repl.end + 1);\n            var before = str.substr(0, Math.max(0, start - currentIndex));\n            if (end <= newCurrentIndex) {\n              var after = str.substr(Math.max(0, end - currentIndex));\n              finalStr += before + repl.content;\n              str = after;\n              currentIndex = Math.max(currentIndex, end);\n            } else {\n              finalStr += before + repl.content;\n              str = \"\";\n              removeChars = end - newCurrentIndex;\n            }\n            idxReplacement--;\n          }\n          str = finalStr + str;\n        }\n        currentIndex = newCurrentIndex;\n        return str;\n      });\n      var extraCode = \"\";\n      while (idxReplacement >= 0) {\n        extraCode += replacements[idxReplacement].content;\n        idxReplacement--;\n      }\n      if (extraCode) {\n        map.add(extraCode);\n      }\n      return map;\n    }\n  }, {\n    key: \"_splitString\",\n    value: function _splitString(str, position) {\n      return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n    }\n  }, {\n    key: \"_replaceInStringNode\",\n    value: function _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n      var original = undefined;\n      do {\n        var splitPosition = replace.position - position;\n        // If multiple replaces occur in the same location then the splitPosition may be\n        // before the current position for the subsequent splits. Ensure it is >= 0\n        if (splitPosition < 0) {\n          splitPosition = 0;\n        }\n        if (splitPosition >= node.length || replace.done) {\n          if (replace.emit) {\n            var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n            output.push(nodeEnd);\n          }\n          return position + node.length;\n        }\n        var originalColumn = mapping.column;\n\n        // Try to figure out if generated code matches original code of this segement\n        // If this is the case we assume that it's allowed to move mapping.column\n        // Because getOriginalSource can be expensive we only do it when neccessary\n\n        var nodePart;\n        if (splitPosition > 0) {\n          nodePart = node.slice(0, splitPosition);\n          if (original === undefined) {\n            original = getOriginalSource(mapping);\n          }\n          if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n            mapping.column += splitPosition;\n            original = original.substr(splitPosition);\n          }\n        }\n        var emit = replace.next();\n        if (!emit) {\n          // Stop emitting when we have found the beginning of the string to replace.\n          // Emit the part of the string before splitPosition\n          if (splitPosition > 0) {\n            var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n            output.push(nodeStart);\n          }\n\n          // Emit the replacement value\n          if (replace.value) {\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n          }\n        }\n\n        // Recurse with remainder of the string as there may be multiple replaces within a single node\n        node = node.substr(splitPosition);\n        position += splitPosition;\n      } while (true);\n    }\n  }]);\n  return ReplaceSource;\n}(Source);\nvar ReplacementEnumerator = /*#__PURE__*/function () {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  function ReplacementEnumerator(replacements) {\n    _classCallCheck(this, ReplacementEnumerator);\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false;\n    // Set initial start position\n    this.next();\n  }\n  _createClass(ReplacementEnumerator, [{\n    key: \"next\",\n    value: function next() {\n      if (this.done) return true;\n      if (this.emit) {\n        // Start point found. stop emitting. set position to find end\n        var repl = this.replacements[this.index];\n        var end = Math.floor(repl.end + 1);\n        this.position = end;\n        this.value = repl.content;\n        this.name = repl.name;\n      } else {\n        // End point found. start emitting. set position to find next start\n        this.index--;\n        if (this.index < 0) {\n          this.done = true;\n        } else {\n          var nextRepl = this.replacements[this.index];\n          var start = Math.floor(nextRepl.start);\n          this.position = start;\n        }\n      }\n      if (this.position < 0) this.position = 0;\n      this.emit = !this.emit;\n      return this.emit;\n    }\n  }, {\n    key: \"footer\",\n    value: function footer() {\n      if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n      if (this.done) {\n        return [];\n      } else {\n        var resultStr = \"\";\n        for (var i = this.index; i >= 0; i--) {\n          var repl = this.replacements[i];\n          // this doesn't need to handle repl.name, because in SourceMaps generated code\n          // without pointer to original source can't have a name\n          resultStr += repl.content;\n        }\n        return resultStr;\n      }\n    }\n  }]);\n  return ReplacementEnumerator;\n}();\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["Source","require","SourceNode","Replacement","start","end","content","insertIndex","name","ReplaceSource","source","_source","_name","replacements","newValue","Error","push","length","pos","options","_replaceString","sort","a","b","diff","str","_sortReplacements","result","forEach","repl","remSource","pop","splitted1","_splitString","Math","floor","splitted2","resultStr","i","node","replace","ReplacementEnumerator","output","position","sources","Object","create","sourcesInLines","walkSourceContents","sourceFile","sourceContent","setSourceContent","replaceInStringNode","_replaceInStringNode","bind","getOriginalSource","mapping","key","lines","split","map","line","substr","column","walk","chunk","remaining","footer","add","listMap","currentIndex","idxReplacement","removeChars","mapGeneratedCode","newCurrentIndex","finalStr","before","max","after","extraCode","original","undefined","splitPosition","done","emit","nodeEnd","originalColumn","nodePart","slice","startsWith","next","nodeStart","value","index","nextRepl","prototype","module","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\n\nclass Replacement {\n\tconstructor(start, end, content, insertIndex, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.insertIndex = insertIndex;\n\t\tthis.name = name;\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis.replacements = [];\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif(typeof newValue !== \"string\")\n\t\t\tthrow new Error(\"insertion must be a string, but is a \" + typeof newValue);\n\t\tthis.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif(typeof newValue !== \"string\")\n\t\t\tthrow new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n\t\tthis.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n\t}\n\n\tsource(options) {\n\t\treturn this._replaceString(this._source.source());\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tthis.replacements.sort(function(a, b) {\n\t\t\tvar diff = b.end - a.end;\n\t\t\tif(diff !== 0)\n\t\t\t\treturn diff;\n\t\t\tdiff = b.start - a.start;\n\t\t\tif(diff !== 0)\n\t\t\t\treturn diff;\n\t\t\treturn b.insertIndex - a.insertIndex;\n\t\t});\n\t}\n\n\t_replaceString(str) {\n\t\tif(typeof str !== \"string\")\n\t\t\tthrow new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n\t\tthis._sortReplacements();\n\t\tvar result = [str];\n\t\tthis.replacements.forEach(function(repl) {\n\t\t\tvar remSource = result.pop();\n\t\t\tvar splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\t\t\tvar splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\t\t\tresult.push(splitted1[1], repl.content, splitted2[0]);\n\t\t}, this);\n\n\t\t// write out result array in reverse order\n\t\tlet resultStr = \"\";\n\t\tfor(let i = result.length - 1; i >= 0; --i) {\n\t\t\tresultStr += result[i];\n\t\t}\n\t\treturn resultStr;\n\t}\n\n\tnode(options) {\n\t\tvar node = this._source.node(options);\n\t\tif(this.replacements.length === 0) {\n\t\t\treturn node;\n\t\t}\n\t\tthis._sortReplacements();\n\t\tvar replace = new ReplacementEnumerator(this.replacements);\n\t\tvar output = [];\n\t\tvar position = 0;\n\t\tvar sources = Object.create(null);\n\t\tvar sourcesInLines = Object.create(null);\n\n\t\t// We build a new list of SourceNodes in \"output\"\n\t\t// from the original mapping data\n\n\t\tvar result = new SourceNode();\n\n\t\t// We need to add source contents manually\n\t\t// because \"walk\" will not handle it\n\t\tnode.walkSourceContents(function(sourceFile, sourceContent) {\n\t\t\tresult.setSourceContent(sourceFile, sourceContent);\n\t\t\tsources[\"$\" + sourceFile] = sourceContent;\n\t\t});\n\n\t\tvar replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n\t\t\tvar key = \"$\" + mapping.source;\n\t\t\tvar lines = sourcesInLines[key];\n\t\t\tif(!lines) {\n\t\t\t\tvar source = sources[key];\n\t\t\t\tif(!source) return null;\n\t\t\t\tlines = source.split(\"\\n\").map(function(line) {\n\t\t\t\t\treturn line + \"\\n\";\n\t\t\t\t});\n\t\t\t\tsourcesInLines[key] = lines;\n\t\t\t}\n\t\t\t// line is 1-based\n\t\t\tif(mapping.line > lines.length) return null;\n\t\t\tvar line = lines[mapping.line - 1];\n\t\t\treturn line.substr(mapping.column);\n\t\t});\n\n\t\tnode.walk(function(chunk, mapping) {\n\t\t\tposition = replaceInStringNode(chunk, position, mapping);\n\t\t});\n\n\t\t// If any replacements occur after the end of the original file, then we append them\n\t\t// directly to the end of the output\n\t\tvar remaining = replace.footer();\n\t\tif(remaining) {\n\t\t\toutput.push(remaining);\n\t\t}\n\n\t\tresult.add(output);\n\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tthis._sortReplacements();\n\t\tvar map = this._source.listMap(options);\n\t\tvar currentIndex = 0;\n\t\tvar replacements = this.replacements;\n\t\tvar idxReplacement = replacements.length - 1;\n\t\tvar removeChars = 0;\n\t\tmap = map.mapGeneratedCode(function(str) {\n\t\t\tvar newCurrentIndex = currentIndex + str.length;\n\t\t\tif(removeChars > str.length) {\n\t\t\t\tremoveChars -= str.length;\n\t\t\t\tstr = \"\";\n\t\t\t} else {\n\t\t\t\tif(removeChars > 0) {\n\t\t\t\t\tstr = str.substr(removeChars);\n\t\t\t\t\tcurrentIndex += removeChars;\n\t\t\t\t\tremoveChars = 0;\n\t\t\t\t}\n\t\t\t\tvar finalStr = \"\";\n\t\t\t\twhile(idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n\t\t\t\t\tvar repl = replacements[idxReplacement];\n\t\t\t\t\tvar start = Math.floor(repl.start);\n\t\t\t\t\tvar end = Math.floor(repl.end + 1);\n\t\t\t\t\tvar before = str.substr(0, Math.max(0, start - currentIndex));\n\t\t\t\t\tif(end <= newCurrentIndex) {\n\t\t\t\t\t\tvar after = str.substr(Math.max(0, end - currentIndex));\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = after;\n\t\t\t\t\t\tcurrentIndex = Math.max(currentIndex, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = \"\";\n\t\t\t\t\t\tremoveChars = end - newCurrentIndex;\n\t\t\t\t\t}\n\t\t\t\t\tidxReplacement--;\n\t\t\t\t}\n\t\t\t\tstr = finalStr + str;\n\t\t\t}\n\t\t\tcurrentIndex = newCurrentIndex;\n\t\t\treturn str;\n\t\t});\n\t\tvar extraCode = \"\";\n\t\twhile(idxReplacement >= 0) {\n\t\t\textraCode += replacements[idxReplacement].content;\n\t\t\tidxReplacement--;\n\t\t}\n\t\tif(extraCode) {\n\t\t\tmap.add(extraCode);\n\t\t}\n\t\treturn map;\n\t}\n\n\t_splitString(str, position) {\n\t\treturn position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n\t}\n\n\t_replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n\t\tvar original = undefined;\n\n\t\tdo {\n\t\t\tvar splitPosition = replace.position - position;\n\t\t\t// If multiple replaces occur in the same location then the splitPosition may be\n\t\t\t// before the current position for the subsequent splits. Ensure it is >= 0\n\t\t\tif(splitPosition < 0) {\n\t\t\t\tsplitPosition = 0;\n\t\t\t}\n\t\t\tif(splitPosition >= node.length || replace.done) {\n\t\t\t\tif(replace.emit) {\n\t\t\t\t\tvar nodeEnd = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeEnd);\n\t\t\t\t}\n\t\t\t\treturn position + node.length;\n\t\t\t}\n\n\t\t\tvar originalColumn = mapping.column;\n\n\t\t\t// Try to figure out if generated code matches original code of this segement\n\t\t\t// If this is the case we assume that it's allowed to move mapping.column\n\t\t\t// Because getOriginalSource can be expensive we only do it when neccessary\n\n\t\t\tvar nodePart;\n\t\t\tif(splitPosition > 0) {\n\t\t\t\tnodePart = node.slice(0, splitPosition);\n\t\t\t\tif(original === undefined) {\n\t\t\t\t\toriginal = getOriginalSource(mapping);\n\t\t\t\t}\n\t\t\t\tif(original && original.length >= splitPosition && original.startsWith(nodePart)) {\n\t\t\t\t\tmapping.column += splitPosition;\n\t\t\t\t\toriginal = original.substr(splitPosition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar emit = replace.next();\n\t\t\tif(!emit) {\n\t\t\t\t// Stop emitting when we have found the beginning of the string to replace.\n\t\t\t\t// Emit the part of the string before splitPosition\n\t\t\t\tif(splitPosition > 0) {\n\t\t\t\t\tvar nodeStart = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnodePart,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeStart);\n\t\t\t\t}\n\n\t\t\t\t// Emit the replacement value\n\t\t\t\tif(replace.value) {\n\t\t\t\t\toutput.push(new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\treplace.value,\n\t\t\t\t\t\tmapping.name || replace.name\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Recurse with remainder of the string as there may be multiple replaces within a single node\n\t\t\tnode = node.substr(splitPosition);\n\t\t\tposition += splitPosition;\n\t\t} while (true);\n\t}\n}\n\nclass ReplacementEnumerator {\n\t/**\n\t * @param {Replacement[]} replacements list of replacements\n\t */\n\tconstructor(replacements) {\n\t\tthis.replacements = replacements || [];\n\t\tthis.index = this.replacements.length;\n\t\tthis.done = false;\n\t\tthis.emit = false;\n\t\t// Set initial start position\n\t\tthis.next();\n\t}\n\n\tnext() {\n\t\tif(this.done)\n\t\t\treturn true;\n\t\tif(this.emit) {\n\t\t\t// Start point found. stop emitting. set position to find end\n\t\t\tvar repl = this.replacements[this.index];\n\t\t\tvar end = Math.floor(repl.end + 1);\n\t\t\tthis.position = end;\n\t\t\tthis.value = repl.content;\n\t\t\tthis.name = repl.name;\n\t\t} else {\n\t\t\t// End point found. start emitting. set position to find next start\n\t\t\tthis.index--;\n\t\t\tif(this.index < 0) {\n\t\t\t\tthis.done = true;\n\t\t\t} else {\n\t\t\t\tvar nextRepl = this.replacements[this.index];\n\t\t\t\tvar start = Math.floor(nextRepl.start);\n\t\t\t\tthis.position = start;\n\t\t\t}\n\t\t}\n\t\tif(this.position < 0)\n\t\t\tthis.position = 0;\n\t\tthis.emit = !this.emit;\n\t\treturn this.emit;\n\t}\n\n\tfooter() {\n\t\tif(!this.done && !this.emit)\n\t\t\tthis.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\t\tif(this.done) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar resultStr = \"\";\n\t\t\tfor(var i = this.index; i >= 0; i--) {\n\t\t\t\tvar repl = this.replacements[i];\n\t\t\t\t// this doesn't need to handle repl.name, because in SourceMaps generated code\n\t\t\t\t// without pointer to original source can't have a name\n\t\t\t\tresultStr += repl.content;\n\t\t\t}\n\t\t\treturn resultStr;\n\t\t}\n\t}\n}\n\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\n\nmodule.exports = ReplaceSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}