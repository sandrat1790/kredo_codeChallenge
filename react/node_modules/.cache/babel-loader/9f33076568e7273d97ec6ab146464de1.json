{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  HookMap = _require.HookMap,\n  SyncHook = _require.SyncHook,\n  SyncWaterfallHook = _require.SyncWaterfallHook;\nvar Factory = require(\"enhanced-resolve\").ResolverFactory;\nvar _require2 = require(\"./util/cleverMerge\"),\n  cachedCleverMerge = _require2.cachedCleverMerge;\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nvar EMTPY_RESOLVE_OPTIONS = {};\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(ResolverFactory, _Tapable);\n  var _super = _createSuper(ResolverFactory);\n  function ResolverFactory() {\n    var _this;\n    _classCallCheck(this, ResolverFactory);\n    _this = _super.call(this);\n    _this.hooks = {\n      resolveOptions: new HookMap(function () {\n        return new SyncWaterfallHook([\"resolveOptions\"]);\n      }),\n      resolver: new HookMap(function () {\n        return new SyncHook([\"resolver\", \"resolveOptions\"]);\n      })\n    };\n    _this._pluginCompat.tap(\"ResolverFactory\", function (options) {\n      var match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n      if (match) {\n        _this.hooks.resolveOptions.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n      match = /^resolver (.+)$/.exec(options.name);\n      if (match) {\n        _this.hooks.resolver.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n    });\n    _this.cache2 = new Map();\n    return _this;\n  }\n  _createClass(ResolverFactory, [{\n    key: \"get\",\n    value: function get(type, resolveOptions) {\n      resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n      var ident = \"\".concat(type, \"|\").concat(JSON.stringify(resolveOptions));\n      var resolver = this.cache2.get(ident);\n      if (resolver) return resolver;\n      var newResolver = this._create(type, resolveOptions);\n      this.cache2.set(ident, newResolver);\n      return newResolver;\n    }\n  }, {\n    key: \"_create\",\n    value: function _create(type, resolveOptions) {\n      var _this2 = this;\n      var originalResolveOptions = Object.assign({}, resolveOptions);\n      resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n      var resolver = Factory.createResolver(resolveOptions);\n      if (!resolver) {\n        throw new Error(\"No resolver created\");\n      }\n      /** @type {Map<Object, Resolver>} */\n      var childCache = new Map();\n      resolver.withOptions = function (options) {\n        var cacheEntry = childCache.get(options);\n        if (cacheEntry !== undefined) return cacheEntry;\n        var mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n        var resolver = _this2.get(type, mergedOptions);\n        childCache.set(options, resolver);\n        return resolver;\n      };\n      this.hooks.resolver.for(type).call(resolver, resolveOptions);\n      return resolver;\n    }\n  }]);\n  return ResolverFactory;\n}(Tapable);","map":{"version":3,"names":["require","Tapable","HookMap","SyncHook","SyncWaterfallHook","Factory","ResolverFactory","cachedCleverMerge","EMTPY_RESOLVE_OPTIONS","module","exports","hooks","resolveOptions","resolver","_pluginCompat","tap","options","match","exec","name","for","fn","cache2","Map","type","ident","JSON","stringify","get","newResolver","_create","set","originalResolveOptions","Object","assign","call","createResolver","Error","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/ResolverFactory.js"],"sourcesContent":["/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst { Tapable, HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { cachedCleverMerge } = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nconst EMTPY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ResolverFactory extends Tapable {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\tresolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n\t\t};\n\t\tthis._pluginCompat.tap(\"ResolverFactory\", options => {\n\t\t\tlet match;\n\t\t\tmatch = /^resolve-options (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolveOptions\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tmatch = /^resolver (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolver\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.cache2 = new Map();\n\t}\n\n\tget(type, resolveOptions) {\n\t\tresolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n\t\tconst ident = `${type}|${JSON.stringify(resolveOptions)}`;\n\t\tconst resolver = this.cache2.get(ident);\n\t\tif (resolver) return resolver;\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\tthis.cache2.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t_create(type, resolveOptions) {\n\t\tconst originalResolveOptions = Object.assign({}, resolveOptions);\n\t\tresolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n\t\tconst resolver = Factory.createResolver(resolveOptions);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {Map<Object, Resolver>} */\n\t\tconst childCache = new Map();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver.for(type).call(resolver, resolveOptions);\n\t\treturn resolver;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}