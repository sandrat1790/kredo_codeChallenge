{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar mm = require(\"micromatch\");\nvar HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nvar HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nvar HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\nvar getMappingFromInfo = function getMappingFromInfo(info, exportName) {\n  var staticMappings = info.static.get(exportName);\n  if (staticMappings !== undefined) {\n    if (staticMappings.length === 1) return staticMappings[0];\n    return undefined;\n  }\n  var dynamicMappings = Array.from(info.dynamic).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      _ = _ref2[0],\n      ignored = _ref2[1];\n    return !ignored.has(exportName);\n  });\n  if (dynamicMappings.length === 1) {\n    return {\n      module: dynamicMappings[0][0],\n      exportName: exportName,\n      checked: true\n    };\n  }\n  return undefined;\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\nvar addStaticReexport = function addStaticReexport(info, exportName, module, innerExportName, checked) {\n  var mappings = info.static.get(exportName);\n  if (mappings !== undefined) {\n    var _iterator = _createForOfIteratorHelper(mappings),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var mapping = _step.value;\n        if (mapping.module === module && mapping.exportName === innerExportName) {\n          mapping.checked = mapping.checked && checked;\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    mappings = [];\n    info.static.set(exportName, mappings);\n  }\n  mappings.push({\n    module: module,\n    exportName: innerExportName,\n    checked: checked\n  });\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\nvar addDynamicReexport = function addDynamicReexport(info, module, ignored) {\n  var existingList = info.dynamic.get(module);\n  if (existingList !== undefined) {\n    var _iterator2 = _createForOfIteratorHelper(existingList),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var key = _step2.value;\n        if (!ignored.has(key)) existingList.delete(key);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } else {\n    info.dynamic.set(module, new Set(ignored));\n  }\n};\nvar SideEffectsFlagPlugin = /*#__PURE__*/function () {\n  function SideEffectsFlagPlugin() {\n    _classCallCheck(this, SideEffectsFlagPlugin);\n  }\n  _createClass(SideEffectsFlagPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", function (nmf) {\n        nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", function (module, data) {\n          var resolveData = data.resourceResolveData;\n          if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n            var sideEffects = resolveData.descriptionFileData.sideEffects;\n            var hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n            if (!hasSideEffects) {\n              module.factoryMeta.sideEffectFree = true;\n            }\n          }\n          return module;\n        });\n        nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", function (module, data) {\n          if (data.settings.sideEffects === false) {\n            module.factoryMeta.sideEffectFree = true;\n          } else if (data.settings.sideEffects === true) {\n            module.factoryMeta.sideEffectFree = false;\n          }\n        });\n      });\n      compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", function (compilation) {\n        compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", function (modules) {\n          /** @type {Map<Module, ReexportInfo>} */\n          var reexportMaps = new Map();\n\n          // Capture reexports of sideEffectFree modules\n          var _iterator3 = _createForOfIteratorHelper(modules),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _module = _step3.value;\n              /** @type {Dependency[]} */\n              var removeDependencies = [];\n              var _iterator7 = _createForOfIteratorHelper(_module.dependencies),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var dep = _step7.value;\n                  if (dep instanceof HarmonyImportSideEffectDependency) {\n                    if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                      removeDependencies.push(dep);\n                    }\n                  } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n                    if (_module.factoryMeta.sideEffectFree) {\n                      var mode = dep.getMode(true);\n                      if (mode.type === \"safe-reexport\" || mode.type === \"checked-reexport\" || mode.type === \"dynamic-reexport\" || mode.type === \"reexport-non-harmony-default\" || mode.type === \"reexport-non-harmony-default-strict\" || mode.type === \"reexport-named-default\") {\n                        var info = reexportMaps.get(_module);\n                        if (!info) {\n                          reexportMaps.set(_module, info = {\n                            static: new Map(),\n                            dynamic: new Map()\n                          });\n                        }\n                        var targetModule = dep._module;\n                        switch (mode.type) {\n                          case \"safe-reexport\":\n                            var _iterator8 = _createForOfIteratorHelper(mode.map),\n                              _step8;\n                            try {\n                              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                                var _step8$value = _slicedToArray(_step8.value, 2),\n                                  key = _step8$value[0],\n                                  id = _step8$value[1];\n                                if (id) {\n                                  addStaticReexport(info, key, targetModule, id, false);\n                                }\n                              }\n                            } catch (err) {\n                              _iterator8.e(err);\n                            } finally {\n                              _iterator8.f();\n                            }\n                            break;\n                          case \"checked-reexport\":\n                            var _iterator9 = _createForOfIteratorHelper(mode.map),\n                              _step9;\n                            try {\n                              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                                var _step9$value = _slicedToArray(_step9.value, 2),\n                                  _key = _step9$value[0],\n                                  _id = _step9$value[1];\n                                if (_id) {\n                                  addStaticReexport(info, _key, targetModule, _id, true);\n                                }\n                              }\n                            } catch (err) {\n                              _iterator9.e(err);\n                            } finally {\n                              _iterator9.f();\n                            }\n                            break;\n                          case \"dynamic-reexport\":\n                            addDynamicReexport(info, targetModule, mode.ignored);\n                            break;\n                          case \"reexport-non-harmony-default\":\n                          case \"reexport-non-harmony-default-strict\":\n                          case \"reexport-named-default\":\n                            addStaticReexport(info, mode.name, targetModule, \"default\", false);\n                            break;\n                        }\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n\n            // Flatten reexports\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var _iterator4 = _createForOfIteratorHelper(reexportMaps.values()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _info = _step4.value;\n              var dynamicReexports = _info.dynamic;\n              _info.dynamic = new Map();\n              var _iterator10 = _createForOfIteratorHelper(dynamicReexports),\n                _step10;\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var reexport = _step10.value;\n                  var _reexport = _slicedToArray(reexport, 2),\n                    _targetModule = _reexport[0],\n                    ignored = _reexport[1];\n                  for (;;) {\n                    var innerInfo = reexportMaps.get(_targetModule);\n                    if (!innerInfo) break;\n                    var _iterator11 = _createForOfIteratorHelper(innerInfo.static),\n                      _step11;\n                    try {\n                      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                        var _step11$value = _slicedToArray(_step11.value, 2),\n                          _key2 = _step11$value[0],\n                          reexports = _step11$value[1];\n                        if (ignored.has(_key2)) continue;\n                        var _iterator13 = _createForOfIteratorHelper(reexports),\n                          _step13;\n                        try {\n                          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                            var _step13$value = _step13.value,\n                              _module2 = _step13$value.module,\n                              exportName = _step13$value.exportName,\n                              checked = _step13$value.checked;\n                            addStaticReexport(_info, _key2, _module2, exportName, checked);\n                          }\n                        } catch (err) {\n                          _iterator13.e(err);\n                        } finally {\n                          _iterator13.f();\n                        }\n                      }\n\n                      // Follow dynamic reexport if there is only one\n                    } catch (err) {\n                      _iterator11.e(err);\n                    } finally {\n                      _iterator11.f();\n                    }\n                    if (innerInfo.dynamic.size !== 1) {\n                      // When there are more then one, we don't know which one\n                      break;\n                    }\n                    ignored = new Set(ignored);\n                    var _iterator12 = _createForOfIteratorHelper(innerInfo.dynamic),\n                      _step12;\n                    try {\n                      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                        var _step12$value = _slicedToArray(_step12.value, 2),\n                          innerModule = _step12$value[0],\n                          innerIgnored = _step12$value[1];\n                        var _iterator14 = _createForOfIteratorHelper(innerIgnored),\n                          _step14;\n                        try {\n                          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                            var _key3 = _step14.value;\n                            if (ignored.has(_key3)) continue;\n                            // This reexports ends here\n                            addStaticReexport(_info, _key3, _targetModule, _key3, true);\n                            ignored.add(_key3);\n                          }\n                        } catch (err) {\n                          _iterator14.e(err);\n                        } finally {\n                          _iterator14.f();\n                        }\n                        _targetModule = innerModule;\n                      }\n                    } catch (err) {\n                      _iterator12.e(err);\n                    } finally {\n                      _iterator12.f();\n                    }\n                  }\n\n                  // Update reexport as all other cases has been handled\n                  addDynamicReexport(_info, _targetModule, ignored);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          var _iterator5 = _createForOfIteratorHelper(reexportMaps.values()),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _info2 = _step5.value;\n              var staticReexports = _info2.static;\n              _info2.static = new Map();\n              var _iterator15 = _createForOfIteratorHelper(staticReexports),\n                _step15;\n              try {\n                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                  var _step15$value = _slicedToArray(_step15.value, 2),\n                    _key4 = _step15$value[0],\n                    _reexports = _step15$value[1];\n                  var _iterator16 = _createForOfIteratorHelper(_reexports),\n                    _step16;\n                  try {\n                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                      var mapping = _step16.value;\n                      for (;;) {\n                        var _innerInfo = reexportMaps.get(mapping.module);\n                        if (!_innerInfo) break;\n                        var newMapping = getMappingFromInfo(_innerInfo, mapping.exportName);\n                        if (!newMapping) break;\n                        mapping = newMapping;\n                      }\n                      addStaticReexport(_info2, _key4, mapping.module, mapping.exportName, mapping.checked);\n                    }\n                  } catch (err) {\n                    _iterator16.e(err);\n                  } finally {\n                    _iterator16.f();\n                  }\n                }\n              } catch (err) {\n                _iterator15.e(err);\n              } finally {\n                _iterator15.f();\n              }\n            }\n\n            // Update imports along the reexports from sideEffectFree modules\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          var _iterator6 = _createForOfIteratorHelper(reexportMaps),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var pair = _step6.value;\n              var _module3 = pair[0];\n              var _info3 = pair[1];\n              var newReasons = undefined;\n              for (var i = 0; i < _module3.reasons.length; i++) {\n                var reason = _module3.reasons[i];\n                var _dep = reason.dependency;\n                if ((_dep instanceof HarmonyExportImportedSpecifierDependency || _dep instanceof HarmonyImportSpecifierDependency && !_dep.namespaceObjectAsContext) && _dep._id) {\n                  var _mapping = getMappingFromInfo(_info3, _dep._id);\n                  if (_mapping) {\n                    _dep.redirectedModule = _mapping.module;\n                    _dep.redirectedId = _mapping.exportName;\n                    _mapping.module.addReason(reason.module, _dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\");\n                    // removing the currect reason, by not adding it to the newReasons array\n                    // lazily create the newReasons array\n                    if (newReasons === undefined) {\n                      newReasons = i === 0 ? [] : _module3.reasons.slice(0, i);\n                    }\n                    continue;\n                  }\n                }\n                if (newReasons !== undefined) newReasons.push(reason);\n              }\n              if (newReasons !== undefined) {\n                _module3.reasons = newReasons;\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"moduleHasSideEffects\",\n    value: function moduleHasSideEffects(moduleName, flagValue) {\n      switch (typeof flagValue) {\n        case \"undefined\":\n          return true;\n        case \"boolean\":\n          return flagValue;\n        case \"string\":\n          if (process.platform === \"win32\") {\n            flagValue = flagValue.replace(/\\\\/g, \"/\");\n          }\n          return mm.isMatch(moduleName, flagValue, {\n            matchBase: true\n          });\n        case \"object\":\n          return flagValue.some(function (glob) {\n            return SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob);\n          });\n      }\n    }\n  }]);\n  return SideEffectsFlagPlugin;\n}();\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"names":["mm","require","HarmonyExportImportedSpecifierDependency","HarmonyImportSideEffectDependency","HarmonyImportSpecifierDependency","getMappingFromInfo","info","exportName","staticMappings","static","get","undefined","length","dynamicMappings","Array","from","dynamic","filter","_","ignored","has","module","checked","addStaticReexport","innerExportName","mappings","mapping","set","push","addDynamicReexport","existingList","key","delete","Set","SideEffectsFlagPlugin","compiler","hooks","normalModuleFactory","tap","nmf","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","hasSideEffects","moduleHasSideEffects","factoryMeta","sideEffectFree","settings","compilation","optimizeDependencies","modules","reexportMaps","Map","removeDependencies","dependencies","dep","mode","getMode","type","targetModule","_module","map","id","name","values","dynamicReexports","reexport","innerInfo","reexports","size","innerModule","innerIgnored","add","staticReexports","newMapping","pair","newReasons","i","reasons","reason","dependency","namespaceObjectAsContext","_id","redirectedModule","redirectedId","addReason","explanation","slice","moduleName","flagValue","process","platform","replace","isMatch","matchBase","some","glob","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\nconst getMappingFromInfo = (info, exportName) => {\n\tconst staticMappings = info.static.get(exportName);\n\tif (staticMappings !== undefined) {\n\t\tif (staticMappings.length === 1) return staticMappings[0];\n\t\treturn undefined;\n\t}\n\tconst dynamicMappings = Array.from(info.dynamic).filter(\n\t\t([_, ignored]) => !ignored.has(exportName)\n\t);\n\tif (dynamicMappings.length === 1) {\n\t\treturn {\n\t\t\tmodule: dynamicMappings[0][0],\n\t\t\texportName,\n\t\t\tchecked: true\n\t\t};\n\t}\n\treturn undefined;\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\nconst addStaticReexport = (\n\tinfo,\n\texportName,\n\tmodule,\n\tinnerExportName,\n\tchecked\n) => {\n\tlet mappings = info.static.get(exportName);\n\tif (mappings !== undefined) {\n\t\tfor (const mapping of mappings) {\n\t\t\tif (mapping.module === module && mapping.exportName === innerExportName) {\n\t\t\t\tmapping.checked = mapping.checked && checked;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmappings = [];\n\t\tinfo.static.set(exportName, mappings);\n\t}\n\tmappings.push({\n\t\tmodule,\n\t\texportName: innerExportName,\n\t\tchecked\n\t});\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\nconst addDynamicReexport = (info, module, ignored) => {\n\tconst existingList = info.dynamic.get(module);\n\tif (existingList !== undefined) {\n\t\tfor (const key of existingList) {\n\t\t\tif (!ignored.has(key)) existingList.delete(key);\n\t\t}\n\t} else {\n\t\tinfo.dynamic.set(module, new Set(ignored));\n\t}\n};\n\nclass SideEffectsFlagPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\tif (\n\t\t\t\t\tresolveData &&\n\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\tresolveData.relativePath\n\t\t\t\t) {\n\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\tsideEffects\n\t\t\t\t\t);\n\t\t\t\t\tif (!hasSideEffects) {\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t});\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tif (data.settings.sideEffects === false) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t} else if (data.settings.sideEffects === true) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tcompiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\t/** @type {Map<Module, ReexportInfo>} */\n\t\t\t\t\tconst reexportMaps = new Map();\n\n\t\t\t\t\t// Capture reexports of sideEffectFree modules\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t/** @type {Dependency[]} */\n\t\t\t\t\t\tconst removeDependencies = [];\n\t\t\t\t\t\tfor (const dep of module.dependencies) {\n\t\t\t\t\t\t\tif (dep instanceof HarmonyImportSideEffectDependency) {\n\t\t\t\t\t\t\t\tif (dep.module && dep.module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tremoveDependencies.push(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tconst mode = dep.getMode(true);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmode.type === \"safe-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"checked-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"dynamic-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default-strict\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-named-default\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tlet info = reexportMaps.get(module);\n\t\t\t\t\t\t\t\t\t\tif (!info) {\n\t\t\t\t\t\t\t\t\t\t\treexportMaps.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\t\t\t\t\tstatic: new Map(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tdynamic: new Map()\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst targetModule = dep._module;\n\t\t\t\t\t\t\t\t\t\tswitch (mode.type) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"safe-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"checked-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"dynamic-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, mode.ignored);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default-strict\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-named-default\":\n\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"default\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Flatten reexports\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst dynamicReexports = info.dynamic;\n\t\t\t\t\t\tinfo.dynamic = new Map();\n\t\t\t\t\t\tfor (const reexport of dynamicReexports) {\n\t\t\t\t\t\t\tlet [targetModule, ignored] = reexport;\n\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(targetModule);\n\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\tfor (const [key, reexports] of innerInfo.static) {\n\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\tfor (const { module, exportName, checked } of reexports) {\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, module, exportName, checked);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Follow dynamic reexport if there is only one\n\t\t\t\t\t\t\t\tif (innerInfo.dynamic.size !== 1) {\n\t\t\t\t\t\t\t\t\t// When there are more then one, we don't know which one\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tignored = new Set(ignored);\n\t\t\t\t\t\t\t\tfor (const [innerModule, innerIgnored] of innerInfo.dynamic) {\n\t\t\t\t\t\t\t\t\tfor (const key of innerIgnored) {\n\t\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\t\t// This reexports ends here\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, targetModule, key, true);\n\t\t\t\t\t\t\t\t\t\tignored.add(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttargetModule = innerModule;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update reexport as all other cases has been handled\n\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst staticReexports = info.static;\n\t\t\t\t\t\tinfo.static = new Map();\n\t\t\t\t\t\tfor (const [key, reexports] of staticReexports) {\n\t\t\t\t\t\t\tfor (let mapping of reexports) {\n\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(mapping.module);\n\t\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\t\tconst newMapping = getMappingFromInfo(\n\t\t\t\t\t\t\t\t\t\tinnerInfo,\n\t\t\t\t\t\t\t\t\t\tmapping.exportName\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!newMapping) break;\n\t\t\t\t\t\t\t\t\tmapping = newMapping;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tmapping.module,\n\t\t\t\t\t\t\t\t\tmapping.exportName,\n\t\t\t\t\t\t\t\t\tmapping.checked\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update imports along the reexports from sideEffectFree modules\n\t\t\t\t\tfor (const pair of reexportMaps) {\n\t\t\t\t\t\tconst module = pair[0];\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tlet newReasons = undefined;\n\t\t\t\t\t\tfor (let i = 0; i < module.reasons.length; i++) {\n\t\t\t\t\t\t\tconst reason = module.reasons[i];\n\t\t\t\t\t\t\tconst dep = reason.dependency;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(dep instanceof HarmonyExportImportedSpecifierDependency ||\n\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)) &&\n\t\t\t\t\t\t\t\tdep._id\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst mapping = getMappingFromInfo(info, dep._id);\n\t\t\t\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\t\t\t\tdep.redirectedModule = mapping.module;\n\t\t\t\t\t\t\t\t\tdep.redirectedId = mapping.exportName;\n\t\t\t\t\t\t\t\t\tmapping.module.addReason(\n\t\t\t\t\t\t\t\t\t\treason.module,\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\treason.explanation\n\t\t\t\t\t\t\t\t\t\t\t? reason.explanation +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" (skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t: \"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// removing the currect reason, by not adding it to the newReasons array\n\t\t\t\t\t\t\t\t\t// lazily create the newReasons array\n\t\t\t\t\t\t\t\t\tif (newReasons === undefined) {\n\t\t\t\t\t\t\t\t\t\tnewReasons = i === 0 ? [] : module.reasons.slice(0, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newReasons !== undefined) newReasons.push(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newReasons !== undefined) {\n\t\t\t\t\t\t\tmodule.reasons = newReasons;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tflagValue = flagValue.replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t\treturn mm.isMatch(moduleName, flagValue, {\n\t\t\t\t\tmatchBase: true\n\t\t\t\t});\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}