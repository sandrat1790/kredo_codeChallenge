{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nvar _toConsumableArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar acorn = require(\"acorn\");\nvar _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  SyncBailHook = _require.SyncBailHook,\n  HookMap = _require.HookMap;\nvar util = require(\"util\");\nvar vm = require(\"vm\");\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nvar StackedSetMap = require(\"./util/StackedSetMap\");\nvar acornParser = acorn.Parser;\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nvar Parser = /*#__PURE__*/function (_Tapable) {\n  _inherits(Parser, _Tapable);\n  var _super = _createSuper(Parser);\n  function Parser(options) {\n    var _this;\n    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    _classCallCheck(this, Parser);\n    _this = _super.call(this);\n    _this.hooks = {\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      assigned: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      callAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    var HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n    _this._pluginCompat.tap(\"Parser\", function (options) {\n      for (var _i = 0, _Object$keys = Object.keys(HOOK_MAP_COMPAT_CONFIG); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        var match = regexp.exec(options.name);\n        if (match) {\n          if (match[1]) {\n            _this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          } else {\n            _this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          }\n          return true;\n        }\n      }\n    });\n    _this.options = options;\n    _this.sourceType = sourceType;\n    _this.scope = undefined;\n    _this.state = undefined;\n    _this.comments = undefined;\n    _this.initializeEvaluating();\n    return _this;\n  }\n  _createClass(Parser, [{\n    key: \"initializeEvaluating\",\n    value: function initializeEvaluating() {\n      var _this2 = this;\n      this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", function (expr) {\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var leftAsBool;\n        var right;\n        if (expr.operator === \"&&\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          if (leftAsBool !== true) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        } else if (expr.operator === \"||\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === true) return left.setRange(expr.range);\n          if (leftAsBool !== false) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var right;\n        var res;\n        if (expr.operator === \"+\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftprefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixright\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number - right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"*\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number * right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"/\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number / right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"**\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(Math.pow(left.number, right.number));\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string === right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number === right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool === right.bool);\n          }\n        } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string !== right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number !== right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool !== right.bool);\n          }\n        } else if (expr.operator === \"&\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number & right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"|\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number | right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"^\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number ^ right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >>> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"<<\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number << right.number);\n          res.setRange(expr.range);\n          return res;\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", function (expr) {\n        if (expr.operator === \"typeof\") {\n          var res;\n          var name;\n          if (expr.argument.type === \"Identifier\") {\n            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;\n            if (!_this2.scope.definitions.has(name)) {\n              var hook = _this2.hooks.evaluateTypeof.get(name);\n              if (hook !== undefined) {\n                res = hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n          if (expr.argument.type === \"MemberExpression\") {\n            var exprName = _this2.getNameForExpression(expr.argument);\n            if (exprName && exprName.free) {\n              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);\n              if (_hook !== undefined) {\n                res = _hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n          if (expr.argument.type === \"FunctionExpression\") {\n            return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n          }\n          var arg = _this2.evaluateExpression(expr.argument);\n          if (arg.isString() || arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n          if (!argument) return;\n          if (argument.isBoolean()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n          }\n          if (argument.isTruthy()) {\n            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n          }\n          if (argument.isFalsy()) {\n            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n          }\n          if (argument.isString()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n          }\n          if (argument.isNumber()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n          }\n        } else if (expr.operator === \"~\") {\n          var _argument = _this2.evaluateExpression(expr.argument);\n          if (!_argument) return;\n          if (!_argument.isNumber()) return;\n          var _res = new BasicEvaluatedExpression();\n          _res.setNumber(~_argument.number);\n          _res.setRange(expr.range);\n          return _res;\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(expr.name) || expr.name;\n        if (!_this2.scope.definitions.has(expr.name)) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        } else {\n          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);\n          if (_hook2 !== undefined) {\n            return _hook2.call(expr);\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(\"this\");\n        if (name) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", function (expression) {\n        var exprName = _this2.getNameForExpression(expression);\n        if (exprName) {\n          if (exprName.free) {\n            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);\n            if (hook !== undefined) {\n              var result = hook.call(expression);\n              if (result) return result;\n            }\n            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n          } else {\n            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);\n            if (_hook3 !== undefined) {\n              return _hook3.call(expression);\n            }\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", function (expr) {\n        if (expr.callee.type !== \"MemberExpression\") return;\n        if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n        var param = _this2.evaluateExpression(expr.callee.object);\n        if (!param) return;\n        var property = expr.callee.property.name || expr.callee.property.value;\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        arg1 = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        arg2 = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n      });\n      [\"substr\", \"substring\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n            str = param.string;\n          switch (expr.arguments.length) {\n            case 1:\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n            case 2:\n              {\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n            default:\n              return;\n          }\n          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n        });\n      });\n\n      /**\n       * @param {string} kind \"cooked\" | \"raw\"\n       * @param {TODO} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        var quasis = [];\n        var parts = [];\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n            var exprAsString = expr.asString();\n            if (typeof exprAsString === \"string\") {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n              // We unset the expression as it doesn't match to a single expression\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n            parts.push(expr);\n          }\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", function (node) {\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n          quasis = _getSimplifiedTemplat.quasis,\n          parts = _getSimplifiedTemplat.parts;\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", function (node) {\n        if (_this2.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n        var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n          quasis = _getSimplifiedTemplat2.quasis,\n          parts = _getSimplifiedTemplat2.parts;\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var argExpr = _this2.evaluateExpression(expr.arguments[i]);\n          if (!argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            break;\n          }\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n        }\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        var result;\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", function (expr) {\n        var condition = _this2.evaluateExpression(expr.test);\n        var conditionValue = condition.asBool();\n        var res;\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n          var alternate = _this2.evaluateExpression(expr.alternate);\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        }\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", function (expr) {\n        var items = expr.elements.map(function (element) {\n          return element !== null && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) this.walkExpression(classy.superClass);\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var wasTopLevel = this.scope.topLevelScope;\n        this.scope.topLevelScope = false;\n        var _iterator = _createForOfIteratorHelper(classy.body.body),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var methodDefinition = _step.value;\n            if (methodDefinition.type === \"MethodDefinition\") {\n              this.walkMethodDefinition(methodDefinition);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.scope.topLevelScope = wasTopLevel;\n      }\n    }\n  }, {\n    key: \"walkMethodDefinition\",\n    value: function walkMethodDefinition(methodDefinition) {\n      if (methodDefinition.computed && methodDefinition.key) {\n        this.walkExpression(methodDefinition.key);\n      }\n      if (methodDefinition.value) {\n        this.walkExpression(methodDefinition.value);\n      }\n    }\n\n    // Prewalking iterates the scope for variable declarations\n  }, {\n    key: \"prewalkStatements\",\n    value: function prewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.prewalkStatement(statement);\n      }\n    }\n\n    // Block-Prewalking iterates the scope for block variable declarations\n  }, {\n    key: \"blockPrewalkStatements\",\n    value: function blockPrewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.blockPrewalkStatement(statement);\n      }\n    }\n\n    // Walking iterates the statements and expressions and processes them\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"prewalkStatement\",\n    value: function prewalkStatement(statement) {\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.prewalkBlockStatement(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.prewalkDoWhileStatement(statement);\n          break;\n        case \"ExportAllDeclaration\":\n          this.prewalkExportAllDeclaration(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.prewalkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.prewalkExportNamedDeclaration(statement);\n          break;\n        case \"ForInStatement\":\n          this.prewalkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.prewalkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.prewalkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.prewalkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.prewalkIfStatement(statement);\n          break;\n        case \"ImportDeclaration\":\n          this.prewalkImportDeclaration(statement);\n          break;\n        case \"LabeledStatement\":\n          this.prewalkLabeledStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.prewalkSwitchStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.prewalkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.prewalkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.prewalkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.prewalkWithStatement(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkStatement\",\n    value: function blockPrewalkStatement(statement) {\n      switch (statement.type) {\n        case \"VariableDeclaration\":\n          this.blockPrewalkVariableDeclaration(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.blockPrewalkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.blockPrewalkExportNamedDeclaration(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.blockPrewalkClassDeclaration(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      if (this.hooks.statement.call(statement) !== undefined) return;\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n    }\n\n    // Real Statements\n  }, {\n    key: \"prewalkBlockStatement\",\n    value: function prewalkBlockStatement(statement) {\n      this.prewalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      var _this3 = this;\n      this.inBlockScope(function () {\n        var body = statement.body;\n        _this3.blockPrewalkStatements(body);\n        _this3.walkStatements(body);\n      });\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"prewalkIfStatement\",\n    value: function prewalkIfStatement(statement) {\n      this.prewalkStatement(statement.consequent);\n      if (statement.alternate) {\n        this.prewalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkStatement(statement.consequent);\n        if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"prewalkLabeledStatement\",\n    value: function prewalkLabeledStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkWithStatement\",\n    value: function prewalkWithStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkSwitchStatement\",\n    value: function prewalkSwitchStatement(statement) {\n      this.prewalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"prewalkTryStatement\",\n    value: function prewalkTryStatement(statement) {\n      this.prewalkStatement(statement.block);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"prewalkWhileStatement\",\n    value: function prewalkWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkDoWhileStatement\",\n    value: function prewalkDoWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"prewalkForStatement\",\n    value: function prewalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.prewalkStatement(statement.init);\n        }\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      var _this4 = this;\n      this.inBlockScope(function () {\n        if (statement.init) {\n          if (statement.init.type === \"VariableDeclaration\") {\n            _this4.blockPrewalkVariableDeclaration(statement.init);\n            _this4.walkStatement(statement.init);\n          } else {\n            _this4.walkExpression(statement.init);\n          }\n        }\n        if (statement.test) {\n          _this4.walkExpression(statement.test);\n        }\n        if (statement.update) {\n          _this4.walkExpression(statement.update);\n        }\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this4.blockPrewalkStatements(body.body);\n          _this4.walkStatements(body.body);\n        } else {\n          _this4.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForInStatement\",\n    value: function prewalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      var _this5 = this;\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this5.blockPrewalkVariableDeclaration(statement.left);\n          _this5.walkVariableDeclaration(statement.left);\n        } else {\n          _this5.walkPattern(statement.left);\n        }\n        _this5.walkExpression(statement.right);\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this5.blockPrewalkStatements(body.body);\n          _this5.walkStatements(body.body);\n        } else {\n          _this5.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForOfStatement\",\n    value: function prewalkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      var _this6 = this;\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this6.blockPrewalkVariableDeclaration(statement.left);\n          _this6.walkVariableDeclaration(statement.left);\n        } else {\n          _this6.walkPattern(statement.left);\n        }\n        _this6.walkExpression(statement.right);\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this6.blockPrewalkStatements(body.body);\n          _this6.walkStatements(body.body);\n        } else {\n          _this6.walkStatement(body);\n        }\n      });\n    }\n\n    // Declarations\n  }, {\n    key: \"prewalkFunctionDeclaration\",\n    value: function prewalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this7 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inFunctionScope(true, statement.params, function () {\n        var _iterator2 = _createForOfIteratorHelper(statement.params),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var param = _step2.value;\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (statement.body.type === \"BlockStatement\") {\n          _this7.detectMode(statement.body.body);\n          _this7.prewalkStatement(statement.body);\n          _this7.walkStatement(statement.body);\n        } else {\n          _this7.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"prewalkImportDeclaration\",\n    value: function prewalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n      var _iterator3 = _createForOfIteratorHelper(statement.specifiers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var specifier = _step3.value;\n          var name = specifier.local.name;\n          this.scope.renames.set(name, null);\n          this.scope.definitions.add(name);\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, \"default\", name);\n              break;\n            case \"ImportSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n              break;\n            case \"ImportNamespaceSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, null, name);\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"enterDeclaration\",\n    value: function enterDeclaration(declaration, onIdent) {\n      switch (declaration.type) {\n        case \"VariableDeclaration\":\n          var _iterator4 = _createForOfIteratorHelper(declaration.declarations),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var declarator = _step4.value;\n              switch (declarator.type) {\n                case \"VariableDeclarator\":\n                  {\n                    this.enterPattern(declarator.id, onIdent);\n                    break;\n                  }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          break;\n        case \"FunctionDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n        case \"ClassDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportNamedDeclaration\",\n    value: function blockPrewalkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.blockPrewalkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportNamedDeclaration\",\n    value: function prewalkExportNamedDeclaration(statement) {\n      var _this8 = this;\n      var source;\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.prewalkStatement(statement.declaration);\n          var index = 0;\n          this.enterDeclaration(statement.declaration, function (def) {\n            _this8.hooks.exportSpecifier.call(statement, def, def, index++);\n          });\n        }\n      }\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportDefaultDeclaration\",\n    value: function blockPrewalkExportDefaultDeclaration(statement) {\n      if (statement.declaration.type === \"ClassDeclaration\") {\n        this.blockPrewalkClassDeclaration(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportDefaultDeclaration\",\n    value: function prewalkExportDefaultDeclaration(statement) {\n      this.prewalkStatement(statement.declaration);\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\") {\n          this.walkFunctionDeclaration(statement.declaration);\n        } else if (statement.declaration.type === \"ClassDeclaration\") {\n          this.walkClassDeclaration(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportAllDeclaration\",\n    value: function prewalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n    }\n  }, {\n    key: \"prewalkVariableDeclaration\",\n    value: function prewalkVariableDeclaration(statement) {\n      if (statement.kind !== \"var\") return;\n      this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n    }\n  }, {\n    key: \"blockPrewalkVariableDeclaration\",\n    value: function blockPrewalkVariableDeclaration(statement) {\n      if (statement.kind === \"var\") return;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n      this._prewalkVariableDeclaration(statement, hookMap);\n    }\n  }, {\n    key: \"_prewalkVariableDeclaration\",\n    value: function _prewalkVariableDeclaration(statement, hookMap) {\n      var _this9 = this;\n      var _iterator5 = _createForOfIteratorHelper(statement.declarations),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var declarator = _step5.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, function (name, decl) {\n                  var hook = hookMap.get(name);\n                  if (hook === undefined || !hook.call(decl)) {\n                    hook = _this9.hooks.varDeclaration.get(name);\n                    if (hook === undefined || !hook.call(decl)) {\n                      _this9.scope.renames.set(name, null);\n                      _this9.scope.definitions.add(name);\n                    }\n                  }\n                });\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator6 = _createForOfIteratorHelper(statement.declarations),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var declarator = _step6.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook4 = this.hooks.rename.get(renameIdentifier);\n                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {\n                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                      this.scope.definitions.delete(declarator.id.name);\n                    }\n                    break;\n                  }\n                }\n                this.walkPattern(declarator.id);\n                if (declarator.init) this.walkExpression(declarator.init);\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"blockPrewalkClassDeclaration\",\n    value: function blockPrewalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"prewalkSwitchCases\",\n    value: function prewalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.prewalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n        this.walkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this10 = this;\n      this.inBlockScope(function () {\n        // Error binding is optional in catch clause since ECMAScript 2019\n        if (catchClause.param !== null) {\n          _this10.enterPattern(catchClause.param, function (ident) {\n            _this10.scope.renames.set(ident, null);\n            _this10.scope.definitions.add(ident);\n          });\n          _this10.walkPattern(catchClause.param);\n        }\n        _this10.prewalkStatement(catchClause.body);\n        _this10.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator7 = _createForOfIteratorHelper(expressions),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var expression = _step7.value;\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n        if (prop.type === \"SpreadElement\") {\n          this.walkExpression(prop.argument);\n          continue;\n        }\n        if (prop.computed) {\n          this.walkExpression(prop.key);\n        }\n        if (prop.shorthand) {\n          this.scope.inShorthand = true;\n        }\n        this.walkExpression(prop.value);\n        if (prop.shorthand) {\n          this.scope.inShorthand = false;\n        }\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this11 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = expression.params;\n\n      // Add function name in scope for recursive calls\n      if (expression.id) {\n        scopeParams.push(expression.id.name);\n      }\n      this.inFunctionScope(true, scopeParams, function () {\n        var _iterator8 = _createForOfIteratorHelper(expression.params),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var param = _step8.value;\n            _this11.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this11.detectMode(expression.body.body);\n          _this11.prewalkStatement(expression.body);\n          _this11.walkStatement(expression.body);\n        } else {\n          _this11.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this12 = this;\n      this.inFunctionScope(false, expression.params, function () {\n        var _iterator9 = _createForOfIteratorHelper(expression.params),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var param = _step9.value;\n            _this12.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this12.detectMode(expression.body.body);\n          _this12.prewalkStatement(expression.body);\n          _this12.walkStatement(expression.body);\n        } else {\n          _this12.walkExpression(expression.body);\n        }\n      });\n    }\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (expression.expressions) this.walkExpressions(expression.expressions);\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var exprName = this.getNameForExpression(expression.argument);\n        if (exprName && exprName.free) {\n          var hook = this.hooks.typeof.get(exprName.name);\n          if (hook !== undefined) {\n            var result = hook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this13 = this;\n      var renameIdentifier = this.getRenameIdentifier(expression.right);\n      if (expression.left.type === \"Identifier\" && renameIdentifier) {\n        var hook = this.hooks.canRename.get(renameIdentifier);\n        if (hook !== undefined && hook.call(expression.right)) {\n          // renaming \"a = b;\"\n          var _hook5 = this.hooks.rename.get(renameIdentifier);\n          if (_hook5 === undefined || !_hook5.call(expression.right)) {\n            this.scope.renames.set(expression.left.name, renameIdentifier);\n            this.scope.definitions.delete(expression.left.name);\n          }\n          return;\n        }\n      }\n      if (expression.left.type === \"Identifier\") {\n        var assignedHook = this.hooks.assigned.get(expression.left.name);\n        if (assignedHook === undefined || !assignedHook.call(expression)) {\n          this.walkExpression(expression.right);\n        }\n        this.scope.renames.set(expression.left.name, null);\n        var assignHook = this.hooks.assign.get(expression.left.name);\n        if (assignHook === undefined || !assignHook.call(expression)) {\n          this.walkExpression(expression.left);\n        }\n        return;\n      }\n      this.walkExpression(expression.right);\n      this.walkPattern(expression.left);\n      this.enterPattern(expression.left, function (name, decl) {\n        _this13.scope.renames.set(name, null);\n      });\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var callee = this.evaluateExpression(expression.callee);\n      if (callee.isIdentifier()) {\n        var hook = this.hooks.new.get(callee.identifier);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) {\n            return;\n          }\n        }\n      }\n      this.walkExpression(expression.callee);\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this14 = this;\n      var renameArgOrThis = function renameArgOrThis(argOrThis) {\n        var renameIdentifier = _this14.getRenameIdentifier(argOrThis);\n        if (renameIdentifier) {\n          var hook = _this14.hooks.canRename.get(renameIdentifier);\n          if (hook !== undefined && hook.call(argOrThis)) {\n            var _hook6 = _this14.hooks.rename.get(renameIdentifier);\n            if (_hook6 === undefined || !_hook6.call(argOrThis)) {\n              return renameIdentifier;\n            }\n          }\n        }\n        _this14.walkExpression(argOrThis);\n      };\n      var params = functionExpression.params;\n      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n      var args = options.map(renameArgOrThis);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = params.filter(function (identifier, idx) {\n        return !args[idx];\n      });\n\n      // Add function name in scope for recursive calls\n      if (functionExpression.id) {\n        scopeParams.push(functionExpression.id.name);\n      }\n      this.inFunctionScope(true, scopeParams, function () {\n        if (renameThis) {\n          _this14.scope.renames.set(\"this\", renameThis);\n        }\n        for (var i = 0; i < args.length; i++) {\n          var param = args[i];\n          if (!param) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n          _this14.scope.renames.set(params[i].name, param);\n        }\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this14.detectMode(functionExpression.body.body);\n          _this14.prewalkStatement(functionExpression.body);\n          _this14.walkStatement(functionExpression.body);\n        } else {\n          _this14.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n        // (function() { }.call/bind(?, ))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type === \"FunctionExpression\") {\n        // (function() { }())\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else if (expression.callee.type === \"Import\") {\n        var result = this.hooks.importCall.call(expression);\n        if (result === true) return;\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      } else {\n        var callee = this.evaluateExpression(expression.callee);\n        if (callee.isIdentifier()) {\n          var callHook = this.hooks.call.get(callee.identifier);\n          if (callHook !== undefined) {\n            var _result = callHook.call(expression);\n            if (_result === true) return;\n          }\n          var identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n          if (identifier !== callee.identifier) {\n            var callAnyHook = this.hooks.callAnyMember.get(identifier);\n            if (callAnyHook !== undefined) {\n              var _result2 = callAnyHook.call(expression);\n              if (_result2 === true) return;\n            }\n          }\n        }\n        if (expression.callee) this.walkExpression(expression.callee);\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var exprName = this.getNameForExpression(expression);\n      if (exprName && exprName.free) {\n        var expressionHook = this.hooks.expression.get(exprName.name);\n        if (expressionHook !== undefined) {\n          var result = expressionHook.call(expression);\n          if (result === true) return;\n        }\n        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n        if (expressionAnyMemberHook !== undefined) {\n          var _result3 = expressionAnyMemberHook.call(expression);\n          if (_result3 === true) return;\n        }\n      }\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      var expressionHook = this.hooks.expression.get(\"this\");\n      if (expressionHook !== undefined) {\n        expressionHook.call(expression);\n      }\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      if (!this.scope.definitions.has(expression.name)) {\n        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n\n    /**\n     * @deprecated\n     * @param {any} params scope params\n     * @param {function(): void} fn inner function\n     * @returns {void}\n     */\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this15 = this;\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      this.scope.renames.set(\"this\", null);\n      this.enterPatterns(params, function (ident) {\n        _this15.scope.renames.set(ident, null);\n        _this15.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inFunctionScope\",\n    value: function inFunctionScope(hasThis, params, fn) {\n      var _this16 = this;\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      if (hasThis) {\n        this.scope.renames.set(\"this\", null);\n      }\n      this.enterPatterns(params, function (ident) {\n        _this16.scope.renames.set(ident, null);\n        _this16.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inBlockScope\",\n    value: function inBlockScope(fn) {\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: oldScope.inTry,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      fn();\n      this.scope = oldScope;\n    }\n\n    // TODO webpack 5: remove this methods\n    // only for backward-compat\n  }, {\n    key: \"detectStrictMode\",\n    value: function detectStrictMode(statements) {\n      this.detectMode(statements);\n    }\n  }, {\n    key: \"detectMode\",\n    value: function detectMode(statements) {\n      var isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n      if (isLiteral && statements[0].expression.value === \"use strict\") {\n        this.scope.isStrict = true;\n      }\n      if (isLiteral && statements[0].expression.value === \"use asm\") {\n        this.scope.isAsmJs = true;\n      }\n    }\n  }, {\n    key: \"enterPatterns\",\n    value: function enterPatterns(patterns, onIdent) {\n      var _iterator10 = _createForOfIteratorHelper(patterns),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var pattern = _step10.value;\n          if (typeof pattern !== \"string\") {\n            this.enterPattern(pattern, onIdent);\n          } else if (pattern) {\n            onIdent(pattern);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n        case \"Property\":\n          this.enterPattern(pattern.value, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      onIdent(pattern.name, pattern);\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result !== undefined) {\n            if (result) {\n              result.setExpression(expression);\n            }\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e);\n        // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n          break;\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n          break;\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(source, initialState) {\n      var ast;\n      var comments;\n      if (typeof source === \"object\" && source !== null) {\n        ast = source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = Parser.parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments\n        });\n      }\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        isAsmJs: false,\n        definitions: new StackedSetMap(),\n        renames: new StackedSetMap()\n      };\n      var state = this.state = initialState || {};\n      this.comments = comments;\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectMode(ast.body);\n        this.prewalkStatements(ast.body);\n        this.blockPrewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n      }\n      this.scope = oldScope;\n      this.state = oldState;\n      this.comments = oldComments;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = Parser.parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      });\n      // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      }\n      // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      return this.comments.filter(function (comment) {\n        return comment.range[0] >= range[0] && comment.range[1] <= range[1];\n      });\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n      var options = {};\n      var errors = [];\n      var _iterator11 = _createForOfIteratorHelper(comments),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var comment = _step11.value;\n          var value = comment.value;\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      var expr = expression;\n      var exprName = [];\n      while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n        exprName.push(expr.computed ? expr.property.value : expr.property.name);\n        expr = expr.object;\n      }\n      var free;\n      if (expr.type === \"Identifier\") {\n        free = !this.scope.definitions.has(expr.name);\n        exprName.push(this.scope.renames.get(expr.name) || expr.name);\n      } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n        free = true;\n        exprName.push(this.scope.renames.get(\"this\"));\n      } else if (expr.type === \"ThisExpression\") {\n        free = this.scope.topLevelScope;\n        exprName.push(\"this\");\n      } else {\n        return null;\n      }\n      var prefix = \"\";\n      for (var i = exprName.length - 1; i >= 2; i--) {\n        prefix += exprName[i] + \".\";\n      }\n      if (exprName.length > 1) {\n        prefix += exprName[1];\n      }\n      var name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n      var nameGeneral = prefix;\n      return {\n        name: name,\n        nameGeneral: nameGeneral,\n        free: free\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n      if (type === \"auto\") {\n        parserOptions.sourceType = \"module\";\n      } else if (parserOptions.sourceType === \"script\") {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n      var ast;\n      var error;\n      var threw = false;\n      try {\n        ast = acornParser.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n        parserOptions.allowReturnOutsideFunction = true;\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n        try {\n          ast = acornParser.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          threw = true;\n        }\n      }\n      if (threw) {\n        throw error;\n      }\n      return ast;\n    }\n  }]);\n  return Parser;\n}(Tapable); // TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":{"version":3,"names":["acorn","require","Tapable","SyncBailHook","HookMap","util","vm","BasicEvaluatedExpression","StackedSetMap","acornParser","Parser","joinRanges","startRange","endRange","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","hooks","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","statement","statementIf","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","canRename","rename","assigned","assign","typeof","importCall","call","callAnyMember","new","expression","expressionAnyMember","expressionConditionalOperator","expressionLogicalOperator","program","HOOK_MAP_COMPAT_CONFIG","_pluginCompat","tap","Object","keys","name","regexp","match","exec","fn","bind","scope","undefined","state","comments","initializeEvaluating","for","expr","value","setNumber","setRange","range","setString","setBoolean","setNull","setRegExp","left","leftAsBool","right","operator","evaluateExpression","asBool","res","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","concat","Math","pow","isBoolean","bool","argument","type","renames","get","definitions","has","hook","exprName","getNameForExpression","free","arg","isArray","isConstArray","isRegExp","isTruthy","isFalsy","result","setIdentifier","callee","property","computed","param","object","arguments","length","arg1","arg2","regExp","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","parts","i","quasiExpr","quasi","prevExpr","expressions","exprAsString","asString","setExpression","push","part","node","setTemplateString","tag","identifier","stringSuffix","hasUnknownParams","argExpr","newString","newRange","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","isIdentifier","classy","superClass","walkExpression","body","wasTopLevel","topLevelScope","methodDefinition","walkMethodDefinition","key","statements","index","len","prewalkStatement","blockPrewalkStatement","walkStatement","prewalkBlockStatement","prewalkDoWhileStatement","prewalkExportAllDeclaration","prewalkExportDefaultDeclaration","prewalkExportNamedDeclaration","prewalkForInStatement","prewalkForOfStatement","prewalkForStatement","prewalkFunctionDeclaration","prewalkIfStatement","prewalkImportDeclaration","prewalkLabeledStatement","prewalkSwitchStatement","prewalkTryStatement","prewalkVariableDeclaration","prewalkWhileStatement","prewalkWithStatement","blockPrewalkVariableDeclaration","blockPrewalkExportDefaultDeclaration","blockPrewalkExportNamedDeclaration","blockPrewalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","prewalkStatements","inBlockScope","blockPrewalkStatements","walkStatements","prewalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","inTry","handler","walkCatchClause","finalizer","init","update","walkPattern","id","set","add","inFunctionScope","params","detectMode","source","specifiers","specifier","local","imported","declaration","onIdent","declarations","declarator","enterPattern","enterDeclaration","def","specifierIndex","exported","_prewalkVariableDeclaration","hookMap","decl","renameIdentifier","getRenameIdentifier","delete","walkClass","switchCases","switchCase","catchClause","ident","pattern","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkLogicalExpression","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","walkExpressions","propIndex","shorthand","inShorthand","scopeParams","walkLeftRightExpression","assignedHook","assignHook","functionExpression","currentThis","renameArgOrThis","argOrThis","renameThis","args","filter","idx","_walkIIFE","slice","callHook","callAnyHook","expressionHook","expressionAnyMemberHook","nameGeneral","oldScope","isStrict","isAsmJs","createChild","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","initialState","ast","parse","oldState","oldComments","comment","getComments","val","runInNewContext","parserOptions","create","allowReturnOutsideFunction","error","threw","Array","defineProperty","prototype","configurable","deprecate","parseCommentOptions","module","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/Parser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\nconst { Tapable, SyncBailHook, HookMap } = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: 11,\n\tsourceType: \"module\",\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass Parser extends Tapable {\n\tconstructor(options, sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\tassigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tcallAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"])\n\t\t};\n\t\tconst HOOK_MAP_COMPAT_CONFIG = {\n\t\t\tevaluateTypeof: /^evaluate typeof (.+)$/,\n\t\t\tevaluateIdentifier: /^evaluate Identifier (.+)$/,\n\t\t\tevaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n\t\t\tevaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n\t\t\tevaluate: /^evaluate (.+)$/,\n\t\t\tlabel: /^label (.+)$/,\n\t\t\tvarDeclarationLet: /^var-let (.+)$/,\n\t\t\tvarDeclarationConst: /^var-const (.+)$/,\n\t\t\tvarDeclarationVar: /^var-var (.+)$/,\n\t\t\tvarDeclaration: /^var (.+)$/,\n\t\t\tcanRename: /^can-rename (.+)$/,\n\t\t\trename: /^rename (.+)$/,\n\t\t\ttypeof: /^typeof (.+)$/,\n\t\t\tassigned: /^assigned (.+)$/,\n\t\t\tassign: /^assign (.+)$/,\n\t\t\tcallAnyMember: /^call (.+)\\.\\*$/,\n\t\t\tcall: /^call (.+)$/,\n\t\t\tnew: /^new (.+)$/,\n\t\t\texpressionConditionalOperator: /^expression \\?:$/,\n\t\t\texpressionAnyMember: /^expression (.+)\\.\\*$/,\n\t\t\texpression: /^expression (.+)$/\n\t\t};\n\t\tthis._pluginCompat.tap(\"Parser\", options => {\n\t\t\tfor (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n\t\t\t\tconst regexp = HOOK_MAP_COMPAT_CONFIG[name];\n\t\t\t\tconst match = regexp.exec(options.name);\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.options = options;\n\t\tthis.sourceType = sourceType;\n\t\tthis.scope = undefined;\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.initializeEvaluating();\n\t}\n\n\tinitializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet leftAsBool;\n\t\t\tlet right;\n\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== true) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== false) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet right;\n\t\t\tlet res;\n\t\t\tif (expr.operator === \"+\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (left.isString()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"leftprefix\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixright\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number - right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number * right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number / right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(Math.pow(left.number, right.number));\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"==\" || expr.operator === \"===\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string === right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number === right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool === right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string !== right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number !== right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool !== right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number & right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number | right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number ^ right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >>> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number << right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\tlet res;\n\t\t\t\tlet name;\n\t\t\t\tif (expr.argument.type === \"Identifier\") {\n\t\t\t\t\tname =\n\t\t\t\t\t\tthis.scope.renames.get(expr.argument.name) || expr.argument.name;\n\t\t\t\t\tif (!this.scope.definitions.has(name)) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"MemberExpression\") {\n\t\t\t\t\tconst exprName = this.getNameForExpression(expr.argument);\n\t\t\t\t\tif (exprName && exprName.free) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(exprName.name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"FunctionExpression\") {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\tif (arg.isString() || arg.isWrapped()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (argument.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.bool)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isTruthy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(false)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isFalsy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(true)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isString()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.string)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.number)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (!argument.isNumber()) return;\n\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(~argument.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(expr.name) || expr.name;\n\t\t\tif (!this.scope.definitions.has(expr.name)) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t} else {\n\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(\"this\");\n\t\t\tif (name) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n\t\t\tlet exprName = this.getNameForExpression(expression);\n\t\t\tif (exprName) {\n\t\t\t\tif (exprName.free) {\n\t\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setIdentifier(exprName.name)\n\t\t\t\t\t\t.setRange(expression.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.callee.type !== \"MemberExpression\") return;\n\t\t\tif (\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tconst param = this.evaluateExpression(expr.callee.object);\n\t\t\tif (!param) return;\n\t\t\tconst property = expr.callee.property.name || expr.callee.property.value;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\targ1 = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\targ2 = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1, arg2))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {string} kind \"cooked\" | \"raw\"\n\t\t * @param {TODO} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\tconst quasis = [];\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (typeof exprAsString === \"string\") {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n\t\t\tif (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst argExpr = this.evaluateExpression(expr.arguments[i]);\n\t\t\t\t\tif (!argExpr.isString() && !argExpr.isNumber()) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\tconst conditionValue = condition.asBool();\n\t\t\tlet res;\n\t\t\tif (conditionValue === undefined) {\n\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t}\n\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t);\n\t\t\t}\n\t\t\tres.setRange(expr.range);\n\t\t\treturn res;\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\treturn element !== null && this.evaluateExpression(element);\n\t\t\t});\n\t\t\tif (!items.every(Boolean)) return;\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setItems(items)\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\twalkClass(classy) {\n\t\tif (classy.superClass) this.walkExpression(classy.superClass);\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\tthis.scope.topLevelScope = false;\n\t\t\tfor (const methodDefinition of classy.body.body) {\n\t\t\t\tif (methodDefinition.type === \"MethodDefinition\") {\n\t\t\t\t\tthis.walkMethodDefinition(methodDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t}\n\t}\n\n\twalkMethodDefinition(methodDefinition) {\n\t\tif (methodDefinition.computed && methodDefinition.key) {\n\t\t\tthis.walkExpression(methodDefinition.key);\n\t\t}\n\t\tif (methodDefinition.value) {\n\t\t\tthis.walkExpression(methodDefinition.value);\n\t\t}\n\t}\n\n\t// Prewalking iterates the scope for variable declarations\n\tprewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.prewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block-Prewalking iterates the scope for block variable declarations\n\tblockPrewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPrewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tprewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.prewalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.prewalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.prewalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.prewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.prewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.prewalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.prewalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.prewalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.prewalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.prewalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.prewalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.prewalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.prewalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.prewalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.prewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.prewalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.prewalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPrewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPrewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPrewalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkStatement(statement) {\n\t\tif (this.hooks.statement.call(statement) !== undefined) return;\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Real Statements\n\tprewalkBlockStatement(statement) {\n\t\tthis.prewalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tthis.blockPrewalkStatements(body);\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tprewalkIfStatement(statement) {\n\t\tthis.prewalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.prewalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkLabeledStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkWithStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkSwitchStatement(statement) {\n\t\tthis.prewalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tprewalkTryStatement(statement) {\n\t\tthis.prewalkStatement(statement.block);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tprewalkWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkDoWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tprewalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.prewalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForOfStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tprewalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tthis.prewalkStatement(statement.body);\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tprewalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tthis.scope.renames.set(name, null);\n\t\t\tthis.scope.definitions.add(name);\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, \"default\", name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(\n\t\t\t\t\t\tstatement,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, null, name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.blockPrewalkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.prewalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPrewalkExportDefaultDeclaration(statement) {\n\t\tif (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\tthis.blockPrewalkClassDeclaration(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportDefaultDeclaration(statement) {\n\t\tthis.prewalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\"\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (statement.declaration.type === \"FunctionDeclaration\") {\n\t\t\t\tthis.walkFunctionDeclaration(statement.declaration);\n\t\t\t} else if (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\t\tthis.walkClassDeclaration(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n\t}\n\n\tprewalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPrewalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._prewalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_prewalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(name, null);\n\t\t\t\t\t\t\t\tthis.scope.definitions.add(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(\n\t\t\t\t\t\t\t\t\tdeclarator.id.name,\n\t\t\t\t\t\t\t\t\tthis.scope.renames.get(renameIdentifier) || renameIdentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.scope.definitions.delete(declarator.id.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPrewalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tprewalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.prewalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\n\t\t\tif (switchCase.test) {\n\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t}\n\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.scope.renames.set(ident, null);\n\t\t\t\t\tthis.scope.definitions.add(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tthis.prewalkStatement(catchClause.body);\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\tthis.walkExpression(prop.argument);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop.computed) {\n\t\t\t\tthis.walkExpression(prop.key);\n\t\t\t}\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = true;\n\t\t\t}\n\t\t\tthis.walkExpression(prop.value);\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t}\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t}\n\n\twalkSequenceExpression(expression) {\n\t\tif (expression.expressions) this.walkExpressions(expression.expressions);\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst exprName = this.getNameForExpression(expression.argument);\n\t\t\tif (exprName && exprName.free) {\n\t\t\t\tconst hook = this.hooks.typeof.get(exprName.name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\tif (expression.left.type === \"Identifier\" && renameIdentifier) {\n\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\tif (hook !== undefined && hook.call(expression.right)) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\tif (hook === undefined || !hook.call(expression.right)) {\n\t\t\t\t\tthis.scope.renames.set(expression.left.name, renameIdentifier);\n\t\t\t\t\tthis.scope.definitions.delete(expression.left.name);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst assignedHook = this.hooks.assigned.get(expression.left.name);\n\t\t\tif (assignedHook === undefined || !assignedHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t\tthis.scope.renames.set(expression.left.name, null);\n\t\t\tconst assignHook = this.hooks.assign.get(expression.left.name);\n\t\t\tif (assignHook === undefined || !assignHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.walkExpression(expression.right);\n\t\tthis.walkPattern(expression.left);\n\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\tthis.scope.renames.set(name, null);\n\t\t});\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\tif (callee.isIdentifier()) {\n\t\t\tconst hook = this.hooks.new.get(callee.identifier);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst renameArgOrThis = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\tif (hook !== undefined && hook.call(argOrThis)) {\n\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\tif (hook === undefined || !hook.call(argOrThis)) {\n\t\t\t\t\t\treturn renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst params = functionExpression.params;\n\t\tconst renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n\t\tconst args = options.map(renameArgOrThis);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis) {\n\t\t\t\tthis.scope.renames.set(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tconst param = args[i];\n\t\t\t\tif (!param) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.scope.renames.set(params[i].name, param);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tthis.prewalkStatement(functionExpression.body);\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkCallExpression(expression) {\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type === \"FunctionExpression\" &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0\n\t\t) {\n\t\t\t// (function() { }.call/bind(?, ))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (expression.callee.type === \"FunctionExpression\") {\n\t\t\t// (function() { }())\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else if (expression.callee.type === \"Import\") {\n\t\t\tlet result = this.hooks.importCall.call(expression);\n\t\t\tif (result === true) return;\n\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t} else {\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst callHook = this.hooks.call.get(callee.identifier);\n\t\t\t\tif (callHook !== undefined) {\n\t\t\t\t\tlet result = callHook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t\tlet identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\t\t\t\tif (identifier !== callee.identifier) {\n\t\t\t\t\tconst callAnyHook = this.hooks.callAnyMember.get(identifier);\n\t\t\t\t\tif (callAnyHook !== undefined) {\n\t\t\t\t\t\tlet result = callAnyHook.call(expression);\n\t\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expression.callee) this.walkExpression(expression.callee);\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprName = this.getNameForExpression(expression);\n\t\tif (exprName && exprName.free) {\n\t\t\tconst expressionHook = this.hooks.expression.get(exprName.name);\n\t\t\tif (expressionHook !== undefined) {\n\t\t\t\tconst result = expressionHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t\tconst expressionAnyMemberHook = this.hooks.expressionAnyMember.get(\n\t\t\t\texprName.nameGeneral\n\t\t\t);\n\t\t\tif (expressionAnyMemberHook !== undefined) {\n\t\t\t\tconst result = expressionAnyMemberHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tconst expressionHook = this.hooks.expression.get(\"this\");\n\t\tif (expressionHook !== undefined) {\n\t\t\texpressionHook.call(expression);\n\t\t}\n\t}\n\n\twalkIdentifier(expression) {\n\t\tif (!this.scope.definitions.has(expression.name)) {\n\t\t\tconst hook = this.hooks.expression.get(\n\t\t\t\tthis.scope.renames.get(expression.name) || expression.name\n\t\t\t);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tthis.scope.renames.set(\"this\", null);\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.scope.renames.set(\"this\", null);\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t// TODO webpack 5: remove this methods\n\t// only for backward-compat\n\tdetectStrictMode(statements) {\n\t\tthis.detectMode(statements);\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tonIdent(pattern.name, pattern);\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\tparse(source, initialState) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tif (typeof source === \"object\" && source !== null) {\n\t\t\tast = source;\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = Parser.parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedSetMap(),\n\t\t\trenames: new StackedSetMap()\n\t\t};\n\t\tconst state = (this.state = initialState || {});\n\t\tthis.comments = comments;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.prewalkStatements(ast.body);\n\t\t\tthis.blockPrewalkStatements(ast.body);\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.scope = oldScope;\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = Parser.parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\tgetComments(range) {\n\t\treturn this.comments.filter(\n\t\t\tcomment => comment.range[0] >= range[0] && comment.range[1] <= range[1]\n\t\t);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\tgetNameForExpression(expression) {\n\t\tlet expr = expression;\n\t\tconst exprName = [];\n\t\twhile (\n\t\t\texpr.type === \"MemberExpression\" &&\n\t\t\texpr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")\n\t\t) {\n\t\t\texprName.push(expr.computed ? expr.property.value : expr.property.name);\n\t\t\texpr = expr.object;\n\t\t}\n\t\tlet free;\n\t\tif (expr.type === \"Identifier\") {\n\t\t\tfree = !this.scope.definitions.has(expr.name);\n\t\t\texprName.push(this.scope.renames.get(expr.name) || expr.name);\n\t\t} else if (\n\t\t\texpr.type === \"ThisExpression\" &&\n\t\t\tthis.scope.renames.get(\"this\")\n\t\t) {\n\t\t\tfree = true;\n\t\t\texprName.push(this.scope.renames.get(\"this\"));\n\t\t} else if (expr.type === \"ThisExpression\") {\n\t\t\tfree = this.scope.topLevelScope;\n\t\t\texprName.push(\"this\");\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tlet prefix = \"\";\n\t\tfor (let i = exprName.length - 1; i >= 2; i--) {\n\t\t\tprefix += exprName[i] + \".\";\n\t\t}\n\t\tif (exprName.length > 1) {\n\t\t\tprefix += exprName[1];\n\t\t}\n\t\tconst name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n\t\tconst nameGeneral = prefix;\n\t\treturn {\n\t\t\tname,\n\t\t\tnameGeneral,\n\t\t\tfree\n\t\t};\n\t}\n\n\tstatic parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\tconst parserOptions = Object.assign(\n\t\t\tObject.create(null),\n\t\t\tdefaultParserOptions,\n\t\t\toptions\n\t\t);\n\n\t\tif (type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"module\";\n\t\t} else if (parserOptions.sourceType === \"script\") {\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t}\n\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\tthrew = true;\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn ast;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {TODO} range Range\n\t\t * @returns {void}\n\t\t * @this {Parser}\n\t\t */\n\t\tfunction(range) {\n\t\t\treturn this.parseCommentOptions(range).options;\n\t\t},\n\t\t\"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\"\n\t)\n});\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}