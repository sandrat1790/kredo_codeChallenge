{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nvar ParserHelpers = require(\"./ParserHelpers\");\nvar NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\nvar RuntimeValue = /*#__PURE__*/function () {\n  function RuntimeValue(fn, fileDependencies) {\n    _classCallCheck(this, RuntimeValue);\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n  _createClass(RuntimeValue, [{\n    key: \"exec\",\n    value: function exec(parser) {\n      if (this.fileDependencies === true) {\n        parser.state.module.buildInfo.cacheable = false;\n      } else {\n        var _iterator = _createForOfIteratorHelper(this.fileDependencies),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fileDependency = _step.value;\n            parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return this.fn({\n        module: parser.state.module\n      });\n    }\n  }]);\n  return RuntimeValue;\n}();\nvar stringifyObj = function stringifyObj(obj, parser) {\n  return \"Object({\" + Object.keys(obj).map(function (key) {\n    var code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nvar toCode = function toCode(code, parser) {\n  if (code === null) {\n    return \"null\";\n  }\n  if (code === undefined) {\n    return \"undefined\";\n  }\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n  return code + \"\";\n};\nvar DefinePlugin = /*#__PURE__*/function () {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  function DefinePlugin(definitions) {\n    _classCallCheck(this, DefinePlugin);\n    this.definitions = definitions;\n  }\n  _createClass(DefinePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler Webpack compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var definitions = this.definitions;\n      compiler.hooks.compilation.tap(\"DefinePlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n        /**\n         * Handler\n         * @param {Parser} parser Parser\n         * @returns {void}\n         */\n        var handler = function handler(parser) {\n          /**\n           * Walk definitions\n           * @param {Object} definitions Definitions map\n           * @param {string} prefix Prefix string\n           * @returns {void}\n           */\n          var walkDefinitions = function walkDefinitions(definitions, prefix) {\n            Object.keys(definitions).forEach(function (key) {\n              var code = definitions[key];\n              if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n                walkDefinitions(code, prefix + key + \".\");\n                applyObjectDefine(prefix + key, code);\n                return;\n              }\n              applyDefineKey(prefix, key);\n              applyDefine(prefix + key, code);\n            });\n          };\n\n          /**\n           * Apply define key\n           * @param {string} prefix Prefix\n           * @param {string} key Key\n           * @returns {void}\n           */\n          var applyDefineKey = function applyDefineKey(prefix, key) {\n            var splittedKey = key.split(\".\");\n            splittedKey.slice(1).forEach(function (_, i) {\n              var fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n              parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n            });\n          };\n\n          /**\n           * Apply Code\n           * @param {string} key Key\n           * @param {CodeValue} code Code\n           * @returns {void}\n           */\n          var applyDefine = function applyDefine(key, code) {\n            var isTypeof = /^typeof\\s+/.test(key);\n            if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n            var recurse = false;\n            var recurseTypeof = false;\n            if (!isTypeof) {\n              parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n              parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n                /**\n                 * this is needed in case there is a recursion in the DefinePlugin\n                 * to prevent an endless recursion\n                 * e.g.: new DefinePlugin({\n                 * \"a\": \"b\",\n                 * \"b\": \"a\"\n                 * });\n                 */\n                if (recurse) return;\n                recurse = true;\n                var res = parser.evaluate(toCode(code, parser));\n                recurse = false;\n                res.setRange(expr.range);\n                return res;\n              });\n              parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n                var strCode = toCode(code, parser);\n                if (/__webpack_require__/.test(strCode)) {\n                  return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n                } else {\n                  return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n                }\n              });\n            }\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"typeof a\": \"typeof b\",\n               * \"typeof b\": \"typeof a\"\n               * });\n               */\n              if (recurseTypeof) return;\n              recurseTypeof = true;\n              var typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n              var res = parser.evaluate(typeofCode);\n              recurseTypeof = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              var typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n              var res = parser.evaluate(typeofCode);\n              if (!res.isString()) return;\n              return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n            });\n          };\n\n          /**\n           * Apply Object\n           * @param {string} key Key\n           * @param {Object} obj Object\n           * @returns {void}\n           */\n          var applyObjectDefine = function applyObjectDefine(key, obj) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n              return new BasicEvaluatedExpression().setTruthy().setRange(expr.range);\n            });\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              return ParserHelpers.evaluateToString(\"object\")(expr);\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n              var strCode = stringifyObj(obj, parser);\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n            });\n          };\n          walkDefinitions(definitions, \"\");\n        };\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n      });\n    }\n  }], [{\n    key: \"runtimeValue\",\n    value: function runtimeValue(fn, fileDependencies) {\n      return new RuntimeValue(fn, fileDependencies);\n    }\n  }]);\n  return DefinePlugin;\n}();\nmodule.exports = DefinePlugin;","map":{"version":3,"names":["ConstDependency","require","BasicEvaluatedExpression","ParserHelpers","NullFactory","RuntimeValue","fn","fileDependencies","parser","state","module","buildInfo","cacheable","fileDependency","add","stringifyObj","obj","Object","keys","map","key","code","JSON","stringify","toCode","join","undefined","exec","RegExp","toString","DefinePlugin","definitions","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","approve","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","toConstantDependencyWithWebpackRequire","toConstantDependency","evaluateTypeof","typeofCode","typeof","isString","string","bind","setTruthy","evaluateToString","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/DefinePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n\tconstructor(fn, fileDependencies) {\n\t\tthis.fn = fn;\n\t\tthis.fileDependencies = fileDependencies || [];\n\t}\n\n\texec(parser) {\n\t\tif (this.fileDependencies === true) {\n\t\t\tparser.state.module.buildInfo.cacheable = false;\n\t\t} else {\n\t\t\tfor (const fileDependency of this.fileDependencies) {\n\t\t\t\tparser.state.module.buildInfo.fileDependencies.add(fileDependency);\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({ module: parser.state.module });\n\t}\n}\n\nconst stringifyObj = (obj, parser) => {\n\treturn (\n\t\t\"Object({\" +\n\t\tObject.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn JSON.stringify(key) + \":\" + toCode(code, parser);\n\t\t\t})\n\t\t\t.join(\",\") +\n\t\t\"})\"\n\t);\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(code.exec(parser), parser);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(code, parser);\n\t}\n\treturn code + \"\";\n};\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\tstatic runtimeValue(fn, fileDependencies) {\n\t\treturn new RuntimeValue(fn, fileDependencies);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler Webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {Parser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(fullKey)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(toCode(code, parser));\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\tconst strCode = toCode(code, parser);\n\t\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr =>\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression().setTruthy().setRange(expr.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\"object\")(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst strCode = stringifyObj(obj, parser);\n\n\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(\"object\")\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}