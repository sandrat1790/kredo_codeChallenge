{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar crypto = require(\"crypto\");\nvar SortableSet = require(\"../util/SortableSet\");\nvar GraphHelpers = require(\"../GraphHelpers\");\nvar _require = require(\"../util/SetHelpers\"),\n  isSubset = _require.isSubset;\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nvar contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nvar deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */deterministicGrouping;\nvar hashFilename = function hashFilename(name) {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return requests;\n};\nvar getModulesSize = function getModulesSize(modules) {\n  var sum = 0;\n  var _iterator2 = _createForOfIteratorHelper(modules),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var m = _step2.value;\n      sum += m.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator3 = _createForOfIteratorHelper(a),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return false;\n};\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  var aSizeReduce = a.size * (a.chunks.size - 1);\n  var bSizeReduce = b.size * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by cache group index\n  var indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n  if (indexDiff) return indexDiff;\n  // 5. by number of modules (to be able to compare by identifier)\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 6. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  var aI = modulesA[Symbol.iterator]();\n  var bI = modulesB[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    var aItem = aI.next();\n    var bItem = bI.next();\n    if (aItem.done) return 0;\n    var aModuleIdentifier = aItem.value.identifier();\n    var bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\nvar compareNumbers = function compareNumbers(a, b) {\n  return a - b;\n};\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\nmodule.exports = /*#__PURE__*/function () {\n  function SplitChunksPlugin(options) {\n    _classCallCheck(this, SplitChunksPlugin);\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n  _createClass(SplitChunksPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {Compiler} compiler webpack compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true;\n          // Give each selected chunk an index (to create strings from chunks)\n          var indexMap = new Map();\n          var index = 1;\n          var _iterator4 = _createForOfIteratorHelper(chunks),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var chunk = _step4.value;\n              indexMap.set(chunk, index++);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          var getKey = function getKey(chunks) {\n            return Array.from(chunks, function (c) {\n              return indexMap.get(c);\n            }).sort(compareNumbers).join();\n          };\n          /** @type {Map<string, Set<Chunk>>} */\n          var chunkSetsInGraph = new Map();\n          var _iterator5 = _createForOfIteratorHelper(compilation.modules),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _module = _step5.value;\n              var chunksKey = getKey(_module.chunksIterable);\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));\n              }\n            }\n\n            // group these set of chunks by count\n            // to allow to check less sets via isSubset\n            // (only smaller sets can be subset)\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          var chunkSetsByCount = new Map();\n          var _iterator6 = _createForOfIteratorHelper(chunkSetsInGraph.values()),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunksSet = _step6.value;\n              var count = chunksSet.size;\n              var array = chunkSetsByCount.get(count);\n              if (array === undefined) {\n                array = [];\n                chunkSetsByCount.set(count, array);\n              }\n              array.push(chunksSet);\n            }\n\n            // Create a list of possible combinations\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n          var getCombinations = function getCombinations(key) {\n            var chunksSet = chunkSetsInGraph.get(key);\n            var array = [chunksSet];\n            if (chunksSet.size > 1) {\n              var _iterator7 = _createForOfIteratorHelper(chunkSetsByCount),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                    count = _step7$value[0],\n                    setArray = _step7$value[1];\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator8 = _createForOfIteratorHelper(setArray),\n                      _step8;\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var set = _step8.value;\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n            return array;\n          };\n\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {string} key a key of the list\n           */\n\n          /**\n           * @typedef {function(Chunk): boolean} ChunkFilterFunction\n           */\n\n          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n          var selectedChunksCacheByChunksSet = new WeakMap();\n\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk>} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n            var entry2 = entry.get(chunkFilter);\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n              var _iterator9 = _createForOfIteratorHelper(chunks),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var chunk = _step9.value;\n                  if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n            return entry2;\n          };\n\n          /**\n           * @typedef {Object} ChunksInfoItem\n           * @property {SortableSet} modules\n           * @property {TODO} cacheGroup\n           * @property {number} cacheGroupIndex\n           * @property {string} name\n           * @property {number} size\n           * @property {Set<Chunk>} chunks\n           * @property {Set<Chunk>} reuseableChunks\n           * @property {Set<string>} chunksKeys\n           */\n\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n          /** @type {Map<string, ChunksInfoItem>} */\n          var chunksInfoMap = new Map();\n\n          /**\n           * @param {TODO} cacheGroup the current cache group\n           * @param {number} cacheGroupIndex the index of the cache group of ordering\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {string} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return;\n            // Determine name for split chunk\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n            // Create key for maps\n            // When it has a name we use the name as key\n            // Elsewise we create the key from chunks and cache group key\n            // This automatically merges equal names\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(selectedChunksKey));\n            // Add module to maps\n            var info = chunksInfoMap.get(key);\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, sortByIdentifier),\n                cacheGroup: cacheGroup,\n                cacheGroupIndex: cacheGroupIndex,\n                name: name,\n                size: 0,\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n            info.modules.add(module);\n            info.size += module.size();\n            if (!info.chunksKeys.has(selectedChunksKey)) {\n              info.chunksKeys.add(selectedChunksKey);\n              var _iterator10 = _createForOfIteratorHelper(selectedChunks),\n                _step10;\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var chunk = _step10.value;\n                  info.chunks.add(chunk);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          };\n\n          // Walk through all modules\n          var _iterator11 = _createForOfIteratorHelper(compilation.modules),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var _module2 = _step11.value;\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(_module2);\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                continue;\n              }\n\n              // Prepare some values\n              var _chunksKey = getKey(_module2.chunksIterable);\n              var combs = combinationsCache.get(_chunksKey);\n              if (combs === undefined) {\n                combs = getCombinations(_chunksKey);\n                combinationsCache.set(_chunksKey, combs);\n              }\n              var cacheGroupIndex = 0;\n              var _iterator14 = _createForOfIteratorHelper(cacheGroups),\n                _step14;\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var cacheGroupSource = _step14.value;\n                  var minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize;\n                  var enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : _this.options.enforceSizeThreshold;\n                  var cacheGroup = {\n                    key: cacheGroupSource.key,\n                    priority: cacheGroupSource.priority || 0,\n                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,\n                    minSize: minSize,\n                    minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : _this.options.minSize,\n                    enforceSizeThreshold: enforceSizeThreshold,\n                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,\n                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,\n                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,\n                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,\n                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,\n                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,\n                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,\n                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n                    _validateSize: minSize > 0,\n                    _conditionalEnforce: enforceSizeThreshold > 0\n                  };\n                  // For all combination of chunk selection\n                  var _iterator15 = _createForOfIteratorHelper(combs),\n                    _step15;\n                  try {\n                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                      var chunkCombination = _step15.value;\n                      // Break if minimum number of chunks is not reached\n                      if (chunkCombination.size < cacheGroup.minChunks) continue;\n                      // Select chunks by configuration\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                        selectedChunks = _getSelectedChunks.chunks,\n                        selectedChunksKey = _getSelectedChunks.key;\n                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, _module2);\n                    }\n                  } catch (err) {\n                    _iterator15.e(err);\n                  } finally {\n                    _iterator15.f();\n                  }\n                  cacheGroupIndex++;\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            }\n\n            // Filter items were size < minSize\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n          var _iterator12 = _createForOfIteratorHelper(chunksInfoMap),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var pair = _step12.value;\n              var info = pair[1];\n              if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n                chunksInfoMap.delete(pair[0]);\n              }\n            }\n\n            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n          var maxSizeQueueMap = new Map();\n          var _loop = function _loop() {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n            var _iterator16 = _createForOfIteratorHelper(chunksInfoMap),\n              _step16;\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var _pair = _step16.value;\n                var key = _pair[0];\n                var _info = _pair[1];\n                if (bestEntry === undefined) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                } else if (compareEntries(bestEntry, _info) < 0) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name;\n            // Variable for the new chunk (lazy created)\n            /** @type {Chunk} */\n            var newChunk = void 0;\n            // When no chunk name, check if we can reuse a chunk instead of creating a new one\n            var isReused = false;\n            if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator17 = _createForOfIteratorHelper(item.chunks),\n                _step17;\n              try {\n                outer: for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                  var _chunk = _step17.value;\n                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;\n                  if (_chunk.hasEntryModule()) continue;\n                  var _iterator18 = _createForOfIteratorHelper(item.modules),\n                    _step18;\n                  try {\n                    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                      var _module3 = _step18.value;\n                      if (!_chunk.containsModule(_module3)) continue outer;\n                    }\n                  } catch (err) {\n                    _iterator18.e(err);\n                  } finally {\n                    _iterator18.f();\n                  }\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {\n                    newChunk = _chunk;\n                  }\n                  chunkName = undefined;\n                  isReused = true;\n                }\n              } catch (err) {\n                _iterator17.e(err);\n              } finally {\n                _iterator17.f();\n              }\n            }\n            // Check if maxRequests condition can be fulfilled\n\n            var selectedChunks = Array.from(item.chunks).filter(function (chunk) {\n              // skip if we address ourself\n              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n            });\n            var enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold;\n\n            // Skip when no chunk selected\n            if (selectedChunks.length === 0) return \"continue\";\n            var usedChunks = new Set(selectedChunks);\n\n            // Check if maxRequests condition can be fulfilled\n            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n              var _iterator19 = _createForOfIteratorHelper(usedChunks),\n                _step19;\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _chunk2 = _step19.value;\n                  // respect max requests\n                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {\n                    usedChunks.delete(_chunk2);\n                  }\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n            var _iterator20 = _createForOfIteratorHelper(usedChunks),\n              _step20;\n            try {\n              outer: for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _chunk5 = _step20.value;\n                var _iterator28 = _createForOfIteratorHelper(item.modules),\n                  _step28;\n                try {\n                  for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                    var _module7 = _step28.value;\n                    if (_chunk5.containsModule(_module7)) continue outer;\n                  }\n                } catch (err) {\n                  _iterator28.e(err);\n                } finally {\n                  _iterator28.f();\n                }\n                usedChunks.delete(_chunk5);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            } // Were some (invalid) chunks removed from usedChunks?\n            // => readd all modules to the queue, as things could have been changed\n            if (usedChunks.size < selectedChunks.length) {\n              if (usedChunks.size >= item.cacheGroup.minChunks) {\n                var chunksArr = Array.from(usedChunks);\n                var _iterator21 = _createForOfIteratorHelper(item.modules),\n                  _step21;\n                try {\n                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                    var _module4 = _step21.value;\n                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);\n                  }\n                } catch (err) {\n                  _iterator21.e(err);\n                } finally {\n                  _iterator21.f();\n                }\n              }\n              return \"continue\";\n            }\n\n            // Create the new chunk if not reusing one\n            if (!isReused) {\n              newChunk = compilation.addChunk(chunkName);\n            }\n            // Walk through all chunks\n            var _iterator22 = _createForOfIteratorHelper(usedChunks),\n              _step22;\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var _chunk6 = _step22.value;\n                // Add graph connections for splitted chunk\n                _chunk6.split(newChunk);\n              }\n\n              // Add a note to the chunk\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n            newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\");\n              // If the chosen name is already an entry point we remove the entry point\n              var entrypoint = compilation.entrypoints.get(chunkName);\n              if (entrypoint) {\n                compilation.entrypoints.delete(chunkName);\n                entrypoint.remove();\n                newChunk.entryModule = undefined;\n              }\n            }\n            if (item.cacheGroup.filename) {\n              if (!newChunk.isOnlyInitial()) {\n                throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + \"(cache group: \".concat(item.cacheGroup.key, \")\"));\n              }\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n            if (!isReused) {\n              // Add all modules to the new chunk\n              var _iterator23 = _createForOfIteratorHelper(item.modules),\n                _step23;\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var _module5 = _step23.value;\n                  if (typeof _module5.chunkCondition === \"function\") {\n                    if (!_module5.chunkCondition(newChunk)) continue;\n                  }\n                  // Add module to new chunk\n                  GraphHelpers.connectChunkAndModule(newChunk, _module5);\n                  // Remove module from used chunks\n                  var _iterator24 = _createForOfIteratorHelper(usedChunks),\n                    _step24;\n                  try {\n                    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                      var _chunk3 = _step24.value;\n                      _chunk3.removeModule(_module5);\n                      _module5.rewriteChunkInReasons(_chunk3, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator24.e(err);\n                  } finally {\n                    _iterator24.f();\n                  }\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator25 = _createForOfIteratorHelper(item.modules),\n                _step25;\n              try {\n                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                  var _module6 = _step25.value;\n                  var _iterator26 = _createForOfIteratorHelper(usedChunks),\n                    _step26;\n                  try {\n                    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                      var _chunk4 = _step26.value;\n                      _chunk4.removeModule(_module6);\n                      _module6.rewriteChunkInReasons(_chunk4, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator26.e(err);\n                  } finally {\n                    _iterator26.f();\n                  }\n                }\n              } catch (err) {\n                _iterator25.e(err);\n              } finally {\n                _iterator25.f();\n              }\n            }\n            if (item.cacheGroup.maxSize > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            }\n\n            // remove all modules from other entries and update size\n            var _iterator27 = _createForOfIteratorHelper(chunksInfoMap),\n              _step27;\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var _step27$value = _slicedToArray(_step27.value, 2),\n                  _key = _step27$value[0],\n                  _info2 = _step27$value[1];\n                if (isOverlap(_info2.chunks, usedChunks)) {\n                  // update modules and total size\n                  // may remove it from the map when < minSize\n                  var oldSize = _info2.modules.size;\n                  var _iterator29 = _createForOfIteratorHelper(item.modules),\n                    _step29;\n                  try {\n                    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                      var _module8 = _step29.value;\n                      _info2.modules.delete(_module8);\n                    }\n                  } catch (err) {\n                    _iterator29.e(err);\n                  } finally {\n                    _iterator29.f();\n                  }\n                  if (_info2.modules.size !== oldSize) {\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                      continue;\n                    }\n                    _info2.size = getModulesSize(_info2.modules);\n                    if (_info2.cacheGroup._validateSize && _info2.size < _info2.cacheGroup.minSize) {\n                      chunksInfoMap.delete(_key);\n                    }\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n          };\n          while (chunksInfoMap.size > 0) {\n            var _ret = _loop();\n            if (_ret === \"continue\") continue;\n          }\n          var incorrectMinMaxSizeSet = new Set();\n\n          // Make sure that maxSize is fulfilled\n          var _iterator13 = _createForOfIteratorHelper(compilation.chunks.slice()),\n            _step13;\n          try {\n            var _loop2 = function _loop2() {\n              var chunk = _step13.value;\n              var _ref = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,\n                minSize = _ref.minSize,\n                maxSize = _ref.maxSize,\n                automaticNameDelimiter = _ref.automaticNameDelimiter,\n                keys = _ref.keys;\n              if (!maxSize) return \"continue\";\n              if (minSize > maxSize) {\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSize, \" \").concat(maxSize);\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n                }\n              }\n              var results = deterministicGroupingForModules({\n                maxSize: Math.max(minSize, maxSize),\n                minSize: minSize,\n                items: chunk.modulesIterable,\n                getKey: function getKey(module) {\n                  var ident = contextify(compilation.options.context, module.identifier());\n                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);\n                  return fullKey.replace(/[\\\\/?]/g, \"_\");\n                },\n                getSize: function getSize(module) {\n                  return module.size();\n                }\n              });\n              results.sort(function (a, b) {\n                if (a.key < b.key) return -1;\n                if (a.key > b.key) return 1;\n                return 0;\n              });\n              for (var i = 0; i < results.length; i++) {\n                var group = results[i];\n                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n                if (name && name.length > 100) {\n                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n                }\n                var newPart = void 0;\n                if (i !== results.length - 1) {\n                  newPart = compilation.addChunk(name);\n                  chunk.split(newPart);\n                  newPart.chunkReason = chunk.chunkReason;\n                  // Add all modules to the new chunk\n                  var _iterator30 = _createForOfIteratorHelper(group.items),\n                    _step30;\n                  try {\n                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                      var _module9 = _step30.value;\n                      if (typeof _module9.chunkCondition === \"function\") {\n                        if (!_module9.chunkCondition(newPart)) continue;\n                      }\n                      // Add module to new chunk\n                      GraphHelpers.connectChunkAndModule(newPart, _module9);\n                      // Remove module from used chunks\n                      chunk.removeModule(_module9);\n                      _module9.rewriteChunkInReasons(chunk, [newPart]);\n                    }\n                  } catch (err) {\n                    _iterator30.e(err);\n                  } finally {\n                    _iterator30.f();\n                  }\n                } else {\n                  // change the chunk to be a part\n                  newPart = chunk;\n                  chunk.name = name;\n                }\n              }\n            };\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var _ret2 = _loop2();\n              if (_ret2 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n        minSize: options.minSize || 0,\n        enforceSizeThreshold: options.enforceSizeThreshold || 0,\n        maxSize: options.maxSize || 0,\n        minChunks: options.minChunks || 1,\n        maxAsyncRequests: options.maxAsyncRequests || 1,\n        maxInitialRequests: options.maxInitialRequests || 1,\n        hidePathInfo: options.hidePathInfo || false,\n        filename: options.filename || undefined,\n        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n          cacheGroups: options.cacheGroups,\n          name: options.name,\n          automaticNameDelimiter: options.automaticNameDelimiter,\n          automaticNameMaxLength: options.automaticNameMaxLength\n        }),\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength || 109,\n        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n      };\n    }\n  }, {\n    key: \"normalizeName\",\n    value: function normalizeName(_ref2) {\n      var name = _ref2.name,\n        automaticNameDelimiter = _ref2.automaticNameDelimiter,\n        automaticNamePrefix = _ref2.automaticNamePrefix,\n        automaticNameMaxLength = _ref2.automaticNameMaxLength;\n      if (name === true) {\n        /** @type {WeakMap<Chunk[], Record<string, string>>} */\n        var cache = new WeakMap();\n        var fn = function fn(module, chunks, cacheGroup) {\n          var cacheEntry = cache.get(chunks);\n          if (cacheEntry === undefined) {\n            cacheEntry = {};\n            cache.set(chunks, cacheEntry);\n          } else if (cacheGroup in cacheEntry) {\n            return cacheEntry[cacheGroup];\n          }\n          var names = chunks.map(function (c) {\n            return c.name;\n          });\n          if (!names.every(Boolean)) {\n            cacheEntry[cacheGroup] = undefined;\n            return;\n          }\n          names.sort();\n          var prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n          var namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n          var name = namePrefix + names.join(automaticNameDelimiter);\n          // Filenames and paths can't be too long otherwise an\n          // ENAMETOOLONG error is raised. If the generated name if too\n          // long, it is truncated and a hash is appended. The limit has\n          // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n          // generating a 256+ character string.\n          if (name.length > automaticNameMaxLength) {\n            var hashedFilename = hashFilename(name);\n            var sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n            name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n          }\n          cacheEntry[cacheGroup] = name;\n          return name;\n        };\n        return fn;\n      }\n      if (typeof name === \"string\") {\n        var _fn = function _fn() {\n          return name;\n        };\n        return _fn;\n      }\n      if (typeof name === \"function\") return name;\n    }\n  }, {\n    key: \"normalizeChunksFilter\",\n    value: function normalizeChunksFilter(chunks) {\n      if (chunks === \"initial\") {\n        return INITIAL_CHUNK_FILTER;\n      }\n      if (chunks === \"async\") {\n        return ASYNC_CHUNK_FILTER;\n      }\n      if (chunks === \"all\") {\n        return ALL_CHUNK_FILTER;\n      }\n      if (typeof chunks === \"function\") return chunks;\n    }\n  }, {\n    key: \"normalizeFallbackCacheGroup\",\n    value: function normalizeFallbackCacheGroup(_ref3, _ref4) {\n      var _ref3$minSize = _ref3.minSize,\n        minSize = _ref3$minSize === void 0 ? undefined : _ref3$minSize,\n        _ref3$maxSize = _ref3.maxSize,\n        maxSize = _ref3$maxSize === void 0 ? undefined : _ref3$maxSize,\n        _ref3$automaticNameDe = _ref3.automaticNameDelimiter,\n        automaticNameDelimiter = _ref3$automaticNameDe === void 0 ? undefined : _ref3$automaticNameDe;\n      var _ref4$minSize = _ref4.minSize,\n        defaultMinSize = _ref4$minSize === void 0 ? undefined : _ref4$minSize,\n        _ref4$maxSize = _ref4.maxSize,\n        defaultMaxSize = _ref4$maxSize === void 0 ? undefined : _ref4$maxSize,\n        _ref4$automaticNameDe = _ref4.automaticNameDelimiter,\n        defaultAutomaticNameDelimiter = _ref4$automaticNameDe === void 0 ? undefined : _ref4$automaticNameDe;\n      return {\n        minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n        maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n      };\n    }\n  }, {\n    key: \"normalizeCacheGroups\",\n    value: function normalizeCacheGroups(_ref5) {\n      var cacheGroups = _ref5.cacheGroups,\n        name = _ref5.name,\n        automaticNameDelimiter = _ref5.automaticNameDelimiter,\n        automaticNameMaxLength = _ref5.automaticNameMaxLength;\n      if (typeof cacheGroups === \"function\") {\n        // TODO webpack 5 remove this\n        if (cacheGroups.length !== 1) {\n          return function (module) {\n            return cacheGroups(module, module.getChunks());\n          };\n        }\n        return cacheGroups;\n      }\n      if (cacheGroups && typeof cacheGroups === \"object\") {\n        var _fn2 = function _fn2(module) {\n          var results;\n          for (var _i = 0, _Object$keys = Object.keys(cacheGroups); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            var option = cacheGroups[key];\n            if (option === false) continue;\n            if (option instanceof RegExp || typeof option === \"string\") {\n              option = {\n                test: option\n              };\n            }\n            if (typeof option === \"function\") {\n              var result = option(module);\n              if (result) {\n                if (results === undefined) results = [];\n                var _iterator31 = _createForOfIteratorHelper(Array.isArray(result) ? result : [result]),\n                  _step31;\n                try {\n                  var _loop3 = function _loop3() {\n                    var r = _step31.value;\n                    var result = Object.assign({\n                      key: key\n                    }, r);\n                    if (result.name) result.getName = function () {\n                      return result.name;\n                    };\n                    if (result.chunks) {\n                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                    }\n                    results.push(result);\n                  };\n                  for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                    _loop3();\n                  }\n                } catch (err) {\n                  _iterator31.e(err);\n                } finally {\n                  _iterator31.f();\n                }\n              }\n            } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n              if (results === undefined) results = [];\n              results.push({\n                key: key,\n                priority: option.priority,\n                getName: SplitChunksPlugin.normalizeName({\n                  name: option.name || name,\n                  automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                  automaticNamePrefix: option.automaticNamePrefix,\n                  automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n                }) || function () {},\n                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n                enforce: option.enforce,\n                minSize: option.minSize,\n                enforceSizeThreshold: option.enforceSizeThreshold,\n                maxSize: option.maxSize,\n                minChunks: option.minChunks,\n                maxAsyncRequests: option.maxAsyncRequests,\n                maxInitialRequests: option.maxInitialRequests,\n                filename: option.filename,\n                reuseExistingChunk: option.reuseExistingChunk\n              });\n            }\n          }\n          return results;\n        };\n        return _fn2;\n      }\n      var fn = function fn() {};\n      return fn;\n    }\n  }, {\n    key: \"checkTest\",\n    value: function checkTest(test, module) {\n      if (test === undefined) return true;\n      if (typeof test === \"function\") {\n        if (test.length !== 1) {\n          return test(module, module.getChunks());\n        }\n        return test(module);\n      }\n      if (typeof test === \"boolean\") return test;\n      if (typeof test === \"string\") {\n        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n          return true;\n        }\n        var _iterator32 = _createForOfIteratorHelper(module.chunksIterable),\n          _step32;\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var chunk = _step32.value;\n            if (chunk.name && chunk.name.startsWith(test)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n        return false;\n      }\n      if (test instanceof RegExp) {\n        if (module.nameForCondition && test.test(module.nameForCondition())) {\n          return true;\n        }\n        var _iterator33 = _createForOfIteratorHelper(module.chunksIterable),\n          _step33;\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var _chunk7 = _step33.value;\n            if (_chunk7.name && test.test(_chunk7.name)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n        return false;\n      }\n      return false;\n    }\n  }]);\n  return SplitChunksPlugin;\n}();","map":{"version":3,"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","groupsIterable","chunkGroup","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","options","SplitChunksPlugin","normalizeOptions","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","set","getKey","Array","from","c","get","join","chunkSetsInGraph","chunksKey","chunksIterable","Set","chunkSetsByCount","values","chunksSet","count","array","undefined","push","combinationsCache","getCombinations","key","setArray","selectedChunksCacheByChunksSet","WeakMap","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","minChunks","getName","info","reuseableChunks","chunksKeys","add","cacheGroups","getCacheGroups","isArray","combs","cacheGroupSource","minSize","enforce","enforceSizeThreshold","chunksFilter","minSizeForMaxSize","maxSize","maxAsyncRequests","Infinity","maxInitialRequests","filename","automaticNameDelimiter","reuseExistingChunk","_validateSize","_conditionalEnforce","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","filter","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","keys","concat","oldSize","incorrectMinMaxSizeSet","fallbackCacheGroup","warningKey","warnings","results","items","modulesIterable","ident","context","nameForCondition","replace","fullKey","getSize","i","group","hidePathInfo","newPart","normalizeChunksFilter","normalizeCacheGroups","automaticNameMaxLength","normalizeFallbackCacheGroup","automaticNamePrefix","cache","fn","cacheEntry","names","map","every","Boolean","prefix","namePrefix","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","Object","option","RegExp","test","result","r","assign","checkTest","normalizeName","startsWith"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tenforceSizeThreshold: options.enforceSizeThreshold || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tenforceSizeThreshold: option.enforceSizeThreshold,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {number} cacheGroupIndex\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst minSize =\n\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.minSize;\n\t\t\t\t\t\t\tconst enforceSizeThreshold =\n\t\t\t\t\t\t\t\tcacheGroupSource.enforceSizeThreshold !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.enforceSizeThreshold\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.enforceSizeThreshold;\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tenforceSizeThreshold,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n\t\t\t\t\t\t\t\t_validateSize: minSize > 0,\n\t\t\t\t\t\t\t\t_conditionalEnforce: enforceSizeThreshold > 0\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst selectedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\titem.size >= item.cacheGroup.enforceSizeThreshold;\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (selectedChunks.length === 0) continue;\n\n\t\t\t\t\t\tconst usedChunks = new Set(selectedChunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < selectedChunks.length) {\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}