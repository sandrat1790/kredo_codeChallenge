{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar t = require(\"@webassemblyjs/ast\");\nvar _require = require(\"@webassemblyjs/wasm-parser\"),\n  decode = _require.decode;\nvar _require2 = require(\"@webassemblyjs/helper-module-context\"),\n  moduleContextFromModuleAST = _require2.moduleContextFromModuleAST;\nvar _require3 = require(\"tapable\"),\n  Tapable = _require3.Tapable;\nvar WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n\nvar JS_COMPAT_TYPES = new Set([\"i32\", \"f32\", \"f64\"]);\n\n/**\n * @param {t.Signature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nvar getJsIncompatibleType = function getJsIncompatibleType(signature) {\n  var _iterator = _createForOfIteratorHelper(signature.params),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var param = _step.value;\n      if (!JS_COMPAT_TYPES.has(param.valtype)) {\n        return \"\".concat(param.valtype, \" as parameter\");\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(signature.results),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var type = _step2.value;\n      if (!JS_COMPAT_TYPES.has(type)) return \"\".concat(type, \" as result\");\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return null;\n};\n\n/**\n * TODO why are there two different Signature types?\n * @param {t.FuncSignature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nvar getJsIncompatibleTypeOfFuncSignature = function getJsIncompatibleTypeOfFuncSignature(signature) {\n  var _iterator3 = _createForOfIteratorHelper(signature.args),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var param = _step3.value;\n      if (!JS_COMPAT_TYPES.has(param)) {\n        return \"\".concat(param, \" as parameter\");\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(signature.result),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var type = _step4.value;\n      if (!JS_COMPAT_TYPES.has(type)) return \"\".concat(type, \" as result\");\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return null;\n};\nvar decoderOpts = {\n  ignoreCodeSection: true,\n  ignoreDataSection: true,\n  // this will avoid having to lookup with identifiers in the ModuleContext\n  ignoreCustomNameSection: true\n};\nvar WebAssemblyParser = /*#__PURE__*/function (_Tapable) {\n  _inherits(WebAssemblyParser, _Tapable);\n  var _super = _createSuper(WebAssemblyParser);\n  function WebAssemblyParser(options) {\n    var _this;\n    _classCallCheck(this, WebAssemblyParser);\n    _this = _super.call(this);\n    _this.hooks = {};\n    _this.options = options;\n    return _this;\n  }\n  _createClass(WebAssemblyParser, [{\n    key: \"parse\",\n    value: function parse(binary, state) {\n      // flag it as ESM\n      state.module.buildMeta.exportsType = \"namespace\";\n\n      // parse it\n      var program = decode(binary, decoderOpts);\n      var module = program.body[0];\n      var moduleContext = moduleContextFromModuleAST(module);\n\n      // extract imports and exports\n      var exports = state.module.buildMeta.providedExports = [];\n      var jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = [];\n      var importedGlobals = [];\n      t.traverse(module, {\n        ModuleExport: function ModuleExport(_ref) {\n          var node = _ref.node;\n          var descriptor = node.descr;\n          if (descriptor.exportType === \"Func\") {\n            var funcidx = descriptor.id.value;\n\n            /** @type {t.FuncSignature} */\n            var funcSignature = moduleContext.getFunction(funcidx);\n            var incompatibleType = getJsIncompatibleTypeOfFuncSignature(funcSignature);\n            if (incompatibleType) {\n              jsIncompatibleExports[node.name] = incompatibleType;\n            }\n          }\n          exports.push(node.name);\n          if (node.descr && node.descr.exportType === \"Global\") {\n            var refNode = importedGlobals[node.descr.id.value];\n            if (refNode) {\n              var dep = new WebAssemblyExportImportedDependency(node.name, refNode.module, refNode.name, refNode.descr.valtype);\n              state.module.addDependency(dep);\n            }\n          }\n        },\n        Global: function Global(_ref2) {\n          var node = _ref2.node;\n          var init = node.init[0];\n          var importNode = null;\n          if (init.id === \"get_global\") {\n            var globalIdx = init.args[0].value;\n            if (globalIdx < importedGlobals.length) {\n              importNode = importedGlobals[globalIdx];\n            }\n          }\n          importedGlobals.push(importNode);\n        },\n        ModuleImport: function ModuleImport(_ref3) {\n          var node = _ref3.node;\n          /** @type {false | string} */\n          var onlyDirectImport = false;\n          if (t.isMemory(node.descr) === true) {\n            onlyDirectImport = \"Memory\";\n          } else if (t.isTable(node.descr) === true) {\n            onlyDirectImport = \"Table\";\n          } else if (t.isFuncImportDescr(node.descr) === true) {\n            var incompatibleType = getJsIncompatibleType(node.descr.signature);\n            if (incompatibleType) {\n              onlyDirectImport = \"Non-JS-compatible Func Sigurature (\".concat(incompatibleType, \")\");\n            }\n          } else if (t.isGlobalType(node.descr) === true) {\n            var type = node.descr.valtype;\n            if (!JS_COMPAT_TYPES.has(type)) {\n              onlyDirectImport = \"Non-JS-compatible Global Type (\".concat(type, \")\");\n            }\n          }\n          var dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, onlyDirectImport);\n          state.module.addDependency(dep);\n          if (t.isGlobalType(node.descr)) {\n            importedGlobals.push(node);\n          }\n        }\n      });\n      return state;\n    }\n  }]);\n  return WebAssemblyParser;\n}(Tapable);\nmodule.exports = WebAssemblyParser;","map":{"version":3,"names":["t","require","decode","moduleContextFromModuleAST","Tapable","WebAssemblyImportDependency","WebAssemblyExportImportedDependency","JS_COMPAT_TYPES","Set","getJsIncompatibleType","signature","params","param","has","valtype","results","type","getJsIncompatibleTypeOfFuncSignature","args","result","decoderOpts","ignoreCodeSection","ignoreDataSection","ignoreCustomNameSection","WebAssemblyParser","options","hooks","binary","state","module","buildMeta","exportsType","program","body","moduleContext","exports","providedExports","jsIncompatibleExports","importedGlobals","traverse","ModuleExport","node","descriptor","descr","exportType","funcidx","id","value","funcSignature","getFunction","incompatibleType","name","push","refNode","dep","addDependency","Global","init","importNode","globalIdx","length","ModuleImport","onlyDirectImport","isMemory","isTable","isFuncImportDescr","isGlobalType"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/wasm/WebAssemblyParser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst t = require(\"@webassemblyjs/ast\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\nconst {\n\tmoduleContextFromModuleAST\n} = require(\"@webassemblyjs/helper-module-context\");\n\nconst { Tapable } = require(\"tapable\");\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n\nconst JS_COMPAT_TYPES = new Set([\"i32\", \"f32\", \"f64\"]);\n\n/**\n * @param {t.Signature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nconst getJsIncompatibleType = signature => {\n\tfor (const param of signature.params) {\n\t\tif (!JS_COMPAT_TYPES.has(param.valtype)) {\n\t\t\treturn `${param.valtype} as parameter`;\n\t\t}\n\t}\n\tfor (const type of signature.results) {\n\t\tif (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;\n\t}\n\treturn null;\n};\n\n/**\n * TODO why are there two different Signature types?\n * @param {t.FuncSignature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nconst getJsIncompatibleTypeOfFuncSignature = signature => {\n\tfor (const param of signature.args) {\n\t\tif (!JS_COMPAT_TYPES.has(param)) {\n\t\t\treturn `${param} as parameter`;\n\t\t}\n\t}\n\tfor (const type of signature.result) {\n\t\tif (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;\n\t}\n\treturn null;\n};\n\nconst decoderOpts = {\n\tignoreCodeSection: true,\n\tignoreDataSection: true,\n\n\t// this will avoid having to lookup with identifiers in the ModuleContext\n\tignoreCustomNameSection: true\n};\n\nclass WebAssemblyParser extends Tapable {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.hooks = {};\n\t\tthis.options = options;\n\t}\n\n\tparse(binary, state) {\n\t\t// flag it as ESM\n\t\tstate.module.buildMeta.exportsType = \"namespace\";\n\n\t\t// parse it\n\t\tconst program = decode(binary, decoderOpts);\n\t\tconst module = program.body[0];\n\n\t\tconst moduleContext = moduleContextFromModuleAST(module);\n\n\t\t// extract imports and exports\n\t\tconst exports = (state.module.buildMeta.providedExports = []);\n\t\tconst jsIncompatibleExports = (state.module.buildMeta.jsIncompatibleExports = []);\n\n\t\tconst importedGlobals = [];\n\t\tt.traverse(module, {\n\t\t\tModuleExport({ node }) {\n\t\t\t\tconst descriptor = node.descr;\n\n\t\t\t\tif (descriptor.exportType === \"Func\") {\n\t\t\t\t\tconst funcidx = descriptor.id.value;\n\n\t\t\t\t\t/** @type {t.FuncSignature} */\n\t\t\t\t\tconst funcSignature = moduleContext.getFunction(funcidx);\n\n\t\t\t\t\tconst incompatibleType = getJsIncompatibleTypeOfFuncSignature(\n\t\t\t\t\t\tfuncSignature\n\t\t\t\t\t);\n\n\t\t\t\t\tif (incompatibleType) {\n\t\t\t\t\t\tjsIncompatibleExports[node.name] = incompatibleType;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\texports.push(node.name);\n\n\t\t\t\tif (node.descr && node.descr.exportType === \"Global\") {\n\t\t\t\t\tconst refNode = importedGlobals[node.descr.id.value];\n\t\t\t\t\tif (refNode) {\n\t\t\t\t\t\tconst dep = new WebAssemblyExportImportedDependency(\n\t\t\t\t\t\t\tnode.name,\n\t\t\t\t\t\t\trefNode.module,\n\t\t\t\t\t\t\trefNode.name,\n\t\t\t\t\t\t\trefNode.descr.valtype\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tstate.module.addDependency(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tGlobal({ node }) {\n\t\t\t\tconst init = node.init[0];\n\n\t\t\t\tlet importNode = null;\n\n\t\t\t\tif (init.id === \"get_global\") {\n\t\t\t\t\tconst globalIdx = init.args[0].value;\n\n\t\t\t\t\tif (globalIdx < importedGlobals.length) {\n\t\t\t\t\t\timportNode = importedGlobals[globalIdx];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\timportedGlobals.push(importNode);\n\t\t\t},\n\n\t\t\tModuleImport({ node }) {\n\t\t\t\t/** @type {false | string} */\n\t\t\t\tlet onlyDirectImport = false;\n\n\t\t\t\tif (t.isMemory(node.descr) === true) {\n\t\t\t\t\tonlyDirectImport = \"Memory\";\n\t\t\t\t} else if (t.isTable(node.descr) === true) {\n\t\t\t\t\tonlyDirectImport = \"Table\";\n\t\t\t\t} else if (t.isFuncImportDescr(node.descr) === true) {\n\t\t\t\t\tconst incompatibleType = getJsIncompatibleType(node.descr.signature);\n\t\t\t\t\tif (incompatibleType) {\n\t\t\t\t\t\tonlyDirectImport = `Non-JS-compatible Func Sigurature (${incompatibleType})`;\n\t\t\t\t\t}\n\t\t\t\t} else if (t.isGlobalType(node.descr) === true) {\n\t\t\t\t\tconst type = node.descr.valtype;\n\t\t\t\t\tif (!JS_COMPAT_TYPES.has(type)) {\n\t\t\t\t\t\tonlyDirectImport = `Non-JS-compatible Global Type (${type})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dep = new WebAssemblyImportDependency(\n\t\t\t\t\tnode.module,\n\t\t\t\t\tnode.name,\n\t\t\t\t\tnode.descr,\n\t\t\t\t\tonlyDirectImport\n\t\t\t\t);\n\n\t\t\t\tstate.module.addDependency(dep);\n\n\t\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\t\timportedGlobals.push(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn state;\n\t}\n}\n\nmodule.exports = WebAssemblyParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}