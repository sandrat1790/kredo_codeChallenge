{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\nfunction cloneAndPrefix(node, prefix, append) {\n  if (typeof node === \"string\") {\n    var result = node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    if (append.length > 0) result = append.pop() + result;\n    if (/\\n$/.test(node)) append.push(prefix);\n    return result;\n  } else {\n    var newNode = new SourceNode(node.line, node.column, node.source, node.children.map(function (node) {\n      return cloneAndPrefix(node, prefix, append);\n    }), node.name);\n    newNode.sourceContents = node.sourceContents;\n    return newNode;\n  }\n}\n;\nvar PrefixSource = /*#__PURE__*/function (_Source) {\n  _inherits(PrefixSource, _Source);\n  var _super = _createSuper(PrefixSource);\n  function PrefixSource(prefix, source) {\n    var _this;\n    _classCallCheck(this, PrefixSource);\n    _this = _super.call(this);\n    _this._source = source;\n    _this._prefix = prefix;\n    return _this;\n  }\n  _createClass(PrefixSource, [{\n    key: \"source\",\n    value: function source() {\n      var node = typeof this._source === \"string\" ? this._source : this._source.source();\n      var prefix = this._prefix;\n      return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n      var prefix = this._prefix;\n      var output = [];\n      var result = new SourceNode();\n      node.walkSourceContents(function (source, content) {\n        result.setSourceContent(source, content);\n      });\n      var needPrefix = true;\n      node.walk(function (chunk, mapping) {\n        var parts = chunk.split(/(\\n)/);\n        for (var i = 0; i < parts.length; i += 2) {\n          var nl = i + 1 < parts.length;\n          var part = parts[i] + (nl ? \"\\n\" : \"\");\n          if (part) {\n            if (needPrefix) {\n              output.push(prefix);\n            }\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, part, mapping.name));\n            needPrefix = nl;\n          }\n        }\n      });\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      var prefix = this._prefix;\n      var map = this._source.listMap(options);\n      return map.mapGeneratedCode(function (code) {\n        return prefix + code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n      });\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (typeof this._source === \"string\") hash.update(this._source);else this._source.updateHash(hash);\n      if (typeof this._prefix === \"string\") hash.update(this._prefix);else this._prefix.updateHash(hash);\n    }\n  }]);\n  return PrefixSource;\n}(Source);\nrequire(\"./SourceAndMapMixin\")(PrefixSource.prototype);\nmodule.exports = PrefixSource;","map":{"version":3,"names":["Source","require","SourceNode","REPLACE_REGEX","cloneAndPrefix","node","prefix","append","result","replace","length","pop","test","push","newNode","line","column","source","children","map","name","sourceContents","PrefixSource","_source","_prefix","options","output","walkSourceContents","content","setSourceContent","needPrefix","walk","chunk","mapping","parts","split","i","nl","part","add","listMap","mapGeneratedCode","code","hash","update","updateHash","prototype","module","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack-sources/lib/PrefixSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nfunction cloneAndPrefix(node, prefix, append) {\n\tif(typeof node === \"string\") {\n\t\tvar result = node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t\tif(append.length > 0) result = append.pop() + result;\n\t\tif(/\\n$/.test(node)) append.push(prefix);\n\t\treturn result;\n\t} else {\n\t\tvar newNode = new SourceNode(\n\t\t\tnode.line,\n\t\t\tnode.column,\n\t\t\tnode.source,\n\t\t\tnode.children.map(function(node) {\n\t\t\t\treturn cloneAndPrefix(node, prefix, append);\n\t\t\t}),\n\t\t\tnode.name\n\t\t);\n\t\tnewNode.sourceContents = node.sourceContents;\n\t\treturn newNode;\n\t}\n};\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tsource() {\n\t\tvar node = typeof this._source === \"string\" ? this._source : this._source.source();\n\t\tvar prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\tnode(options) {\n\t\tvar node = this._source.node(options);\n\t\tvar prefix = this._prefix;\n\t\tvar output = [];\n\t\tvar result = new SourceNode();\n\t\tnode.walkSourceContents(function(source, content) {\n\t\t\tresult.setSourceContent(source, content);\n\t\t});\n\t\tvar needPrefix = true;\n\t\tnode.walk(function(chunk, mapping) {\n\t\t\tvar parts = chunk.split(/(\\n)/);\n\t\t\tfor(var i = 0; i < parts.length; i += 2) {\n\t\t\t\tvar nl = i + 1 < parts.length;\n\t\t\t\tvar part = parts[i] + (nl ? \"\\n\" : \"\");\n\t\t\t\tif(part) {\n\t\t\t\t\tif(needPrefix) {\n\t\t\t\t\t\toutput.push(prefix);\n\t\t\t\t\t}\n\t\t\t\t\toutput.push(new SourceNode(mapping.line, mapping.column, mapping.source, part, mapping.name));\n\t\t\t\t\tneedPrefix = nl;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tresult.add(output);\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tvar prefix = this._prefix;\n\t\tvar map = this._source.listMap(options);\n\t\treturn map.mapGeneratedCode(function(code) {\n\t\t\treturn prefix + code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t\t});\n\t}\n\n\tupdateHash(hash) {\n\t\tif(typeof this._source === \"string\")\n\t\t\thash.update(this._source);\n\t\telse\n\t\t\tthis._source.updateHash(hash);\n\t\tif(typeof this._prefix === \"string\")\n\t\t\thash.update(this._prefix);\n\t\telse\n\t\t\tthis._prefix.updateHash(hash);\n\t}\n}\n\nrequire(\"./SourceAndMapMixin\")(PrefixSource.prototype);\n\nmodule.exports = PrefixSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}