{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar AliasPlugin = require(\"enhanced-resolve/lib/AliasPlugin\");\nvar ParserHelpers = require(\"../ParserHelpers\");\nvar nodeLibsBrowser = require(\"node-libs-browser\");\nmodule.exports = /*#__PURE__*/function () {\n  function NodeSourcePlugin(options) {\n    _classCallCheck(this, NodeSourcePlugin);\n    this.options = options;\n  }\n  _createClass(NodeSourcePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      if (options === false) {\n        // allow single kill switch to turn off this plugin\n        return;\n      }\n      var getPathToModule = function getPathToModule(module, type) {\n        if (type === true || type === undefined && nodeLibsBrowser[module]) {\n          if (!nodeLibsBrowser[module]) {\n            throw new Error(\"No browser version for node.js core module \".concat(module, \" available\"));\n          }\n          return nodeLibsBrowser[module];\n        } else if (type === \"mock\") {\n          return require.resolve(\"node-libs-browser/mock/\".concat(module));\n        } else if (type === \"empty\") {\n          return require.resolve(\"node-libs-browser/mock/empty\");\n        } else {\n          return module;\n        }\n      };\n      var addExpression = function addExpression(parser, name, module, type, suffix) {\n        suffix = suffix || \"\";\n        parser.hooks.expression.for(name).tap(\"NodeSourcePlugin\", function () {\n          if (parser.state.module && parser.state.module.resource === getPathToModule(module, type)) return;\n          var mockModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, getPathToModule(module, type));\n          return ParserHelpers.addParsedVariableToModule(parser, name, mockModule + suffix);\n        });\n      };\n      compiler.hooks.compilation.tap(\"NodeSourcePlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        var handler = function handler(parser, parserOptions) {\n          if (parserOptions.node === false) return;\n          var localOptions = options;\n          if (parserOptions.node) {\n            localOptions = Object.assign({}, localOptions, parserOptions.node);\n          }\n          if (localOptions.global) {\n            parser.hooks.expression.for(\"global\").tap(\"NodeSourcePlugin\", function () {\n              var retrieveGlobalModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, require.resolve(\"../../buildin/global\"));\n              return ParserHelpers.addParsedVariableToModule(parser, \"global\", retrieveGlobalModule);\n            });\n          }\n          if (localOptions.process) {\n            var processType = localOptions.process;\n            addExpression(parser, \"process\", \"process\", processType);\n          }\n          if (localOptions.console) {\n            var consoleType = localOptions.console;\n            addExpression(parser, \"console\", \"console\", consoleType);\n          }\n          var bufferType = localOptions.Buffer;\n          if (bufferType) {\n            addExpression(parser, \"Buffer\", \"buffer\", bufferType, \".Buffer\");\n          }\n          if (localOptions.setImmediate) {\n            var setImmediateType = localOptions.setImmediate;\n            addExpression(parser, \"setImmediate\", \"timers\", setImmediateType, \".setImmediate\");\n            addExpression(parser, \"clearImmediate\", \"timers\", setImmediateType, \".clearImmediate\");\n          }\n        };\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"NodeSourcePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"NodeSourcePlugin\", handler);\n      });\n      compiler.hooks.afterResolvers.tap(\"NodeSourcePlugin\", function (compiler) {\n        var _loop = function _loop() {\n          var lib = _Object$keys[_i];\n          if (options[lib] !== false) {\n            compiler.resolverFactory.hooks.resolver.for(\"normal\").tap(\"NodeSourcePlugin\", function (resolver) {\n              new AliasPlugin(\"described-resolve\", {\n                name: lib,\n                onlyModule: true,\n                alias: getPathToModule(lib, options[lib])\n              }, \"resolve\").apply(resolver);\n            });\n          }\n        };\n        for (var _i = 0, _Object$keys = Object.keys(nodeLibsBrowser); _i < _Object$keys.length; _i++) {\n          _loop();\n        }\n      });\n    }\n  }]);\n  return NodeSourcePlugin;\n}();","map":{"version":3,"names":["AliasPlugin","require","ParserHelpers","nodeLibsBrowser","module","exports","options","compiler","getPathToModule","type","undefined","Error","resolve","addExpression","parser","name","suffix","hooks","expression","for","tap","state","resource","mockModule","requireFileAsExpression","context","addParsedVariableToModule","compilation","normalModuleFactory","handler","parserOptions","node","localOptions","Object","assign","global","retrieveGlobalModule","process","processType","console","consoleType","bufferType","Buffer","setImmediate","setImmediateType","afterResolvers","lib","resolverFactory","resolver","onlyModule","alias","apply","keys"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/node/NodeSourcePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\nconst AliasPlugin = require(\"enhanced-resolve/lib/AliasPlugin\");\nconst ParserHelpers = require(\"../ParserHelpers\");\nconst nodeLibsBrowser = require(\"node-libs-browser\");\n\nmodule.exports = class NodeSourcePlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tif (options === false) {\n\t\t\t// allow single kill switch to turn off this plugin\n\t\t\treturn;\n\t\t}\n\n\t\tconst getPathToModule = (module, type) => {\n\t\t\tif (type === true || (type === undefined && nodeLibsBrowser[module])) {\n\t\t\t\tif (!nodeLibsBrowser[module]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No browser version for node.js core module ${module} available`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn nodeLibsBrowser[module];\n\t\t\t} else if (type === \"mock\") {\n\t\t\t\treturn require.resolve(`node-libs-browser/mock/${module}`);\n\t\t\t} else if (type === \"empty\") {\n\t\t\t\treturn require.resolve(\"node-libs-browser/mock/empty\");\n\t\t\t} else {\n\t\t\t\treturn module;\n\t\t\t}\n\t\t};\n\n\t\tconst addExpression = (parser, name, module, type, suffix) => {\n\t\t\tsuffix = suffix || \"\";\n\t\t\tparser.hooks.expression.for(name).tap(\"NodeSourcePlugin\", () => {\n\t\t\t\tif (\n\t\t\t\t\tparser.state.module &&\n\t\t\t\t\tparser.state.module.resource === getPathToModule(module, type)\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\tconst mockModule = ParserHelpers.requireFileAsExpression(\n\t\t\t\t\tparser.state.module.context,\n\t\t\t\t\tgetPathToModule(module, type)\n\t\t\t\t);\n\t\t\t\treturn ParserHelpers.addParsedVariableToModule(\n\t\t\t\t\tparser,\n\t\t\t\t\tname,\n\t\t\t\t\tmockModule + suffix\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"NodeSourcePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.node === false) return;\n\n\t\t\t\t\tlet localOptions = options;\n\t\t\t\t\tif (parserOptions.node) {\n\t\t\t\t\t\tlocalOptions = Object.assign({}, localOptions, parserOptions.node);\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.global) {\n\t\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t\t.for(\"global\")\n\t\t\t\t\t\t\t.tap(\"NodeSourcePlugin\", () => {\n\t\t\t\t\t\t\t\tconst retrieveGlobalModule = ParserHelpers.requireFileAsExpression(\n\t\t\t\t\t\t\t\t\tparser.state.module.context,\n\t\t\t\t\t\t\t\t\trequire.resolve(\"../../buildin/global\")\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn ParserHelpers.addParsedVariableToModule(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\"global\",\n\t\t\t\t\t\t\t\t\tretrieveGlobalModule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.process) {\n\t\t\t\t\t\tconst processType = localOptions.process;\n\t\t\t\t\t\taddExpression(parser, \"process\", \"process\", processType);\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.console) {\n\t\t\t\t\t\tconst consoleType = localOptions.console;\n\t\t\t\t\t\taddExpression(parser, \"console\", \"console\", consoleType);\n\t\t\t\t\t}\n\t\t\t\t\tconst bufferType = localOptions.Buffer;\n\t\t\t\t\tif (bufferType) {\n\t\t\t\t\t\taddExpression(parser, \"Buffer\", \"buffer\", bufferType, \".Buffer\");\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.setImmediate) {\n\t\t\t\t\t\tconst setImmediateType = localOptions.setImmediate;\n\t\t\t\t\t\taddExpression(\n\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\"setImmediate\",\n\t\t\t\t\t\t\t\"timers\",\n\t\t\t\t\t\t\tsetImmediateType,\n\t\t\t\t\t\t\t\".setImmediate\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\taddExpression(\n\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\"clearImmediate\",\n\t\t\t\t\t\t\t\"timers\",\n\t\t\t\t\t\t\tsetImmediateType,\n\t\t\t\t\t\t\t\".clearImmediate\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"NodeSourcePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"NodeSourcePlugin\", handler);\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.afterResolvers.tap(\"NodeSourcePlugin\", compiler => {\n\t\t\tfor (const lib of Object.keys(nodeLibsBrowser)) {\n\t\t\t\tif (options[lib] !== false) {\n\t\t\t\t\tcompiler.resolverFactory.hooks.resolver\n\t\t\t\t\t\t.for(\"normal\")\n\t\t\t\t\t\t.tap(\"NodeSourcePlugin\", resolver => {\n\t\t\t\t\t\t\tnew AliasPlugin(\n\t\t\t\t\t\t\t\t\"described-resolve\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: lib,\n\t\t\t\t\t\t\t\t\tonlyModule: true,\n\t\t\t\t\t\t\t\t\talias: getPathToModule(lib, options[lib])\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"resolve\"\n\t\t\t\t\t\t\t).apply(resolver);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAAC;AAAA;AACb,IAAMA,WAAW,GAAGC,OAAO,CAAC,kCAAkC,CAAC;AAC/D,IAAMC,aAAa,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACjD,IAAME,eAAe,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAEpDG,MAAM,CAACC,OAAO;EACb,0BAAYC,OAAO,EAAE;IAAA;IACpB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACvB;EAAC;IAAA;IAAA,OACD,eAAMC,QAAQ,EAAE;MACf,IAAMD,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5B,IAAIA,OAAO,KAAK,KAAK,EAAE;QACtB;QACA;MACD;MAEA,IAAME,eAAe,GAAG,SAAlBA,eAAe,CAAIJ,MAAM,EAAEK,IAAI,EAAK;QACzC,IAAIA,IAAI,KAAK,IAAI,IAAKA,IAAI,KAAKC,SAAS,IAAIP,eAAe,CAACC,MAAM,CAAE,EAAE;UACrE,IAAI,CAACD,eAAe,CAACC,MAAM,CAAC,EAAE;YAC7B,MAAM,IAAIO,KAAK,sDACgCP,MAAM,gBACpD;UACF;UACA,OAAOD,eAAe,CAACC,MAAM,CAAC;QAC/B,CAAC,MAAM,IAAIK,IAAI,KAAK,MAAM,EAAE;UAC3B,OAAOR,OAAO,CAACW,OAAO,kCAA2BR,MAAM,EAAG;QAC3D,CAAC,MAAM,IAAIK,IAAI,KAAK,OAAO,EAAE;UAC5B,OAAOR,OAAO,CAACW,OAAO,CAAC,8BAA8B,CAAC;QACvD,CAAC,MAAM;UACN,OAAOR,MAAM;QACd;MACD,CAAC;MAED,IAAMS,aAAa,GAAG,SAAhBA,aAAa,CAAIC,MAAM,EAAEC,IAAI,EAAEX,MAAM,EAAEK,IAAI,EAAEO,MAAM,EAAK;QAC7DA,MAAM,GAAGA,MAAM,IAAI,EAAE;QACrBF,MAAM,CAACG,KAAK,CAACC,UAAU,CAACC,GAAG,CAACJ,IAAI,CAAC,CAACK,GAAG,CAAC,kBAAkB,EAAE,YAAM;UAC/D,IACCN,MAAM,CAACO,KAAK,CAACjB,MAAM,IACnBU,MAAM,CAACO,KAAK,CAACjB,MAAM,CAACkB,QAAQ,KAAKd,eAAe,CAACJ,MAAM,EAAEK,IAAI,CAAC,EAE9D;UACD,IAAMc,UAAU,GAAGrB,aAAa,CAACsB,uBAAuB,CACvDV,MAAM,CAACO,KAAK,CAACjB,MAAM,CAACqB,OAAO,EAC3BjB,eAAe,CAACJ,MAAM,EAAEK,IAAI,CAAC,CAC7B;UACD,OAAOP,aAAa,CAACwB,yBAAyB,CAC7CZ,MAAM,EACNC,IAAI,EACJQ,UAAU,GAAGP,MAAM,CACnB;QACF,CAAC,CAAC;MACH,CAAC;MAEDT,QAAQ,CAACU,KAAK,CAACU,WAAW,CAACP,GAAG,CAC7B,kBAAkB,EAClB,UAACO,WAAW,QAA8B;QAAA,IAA1BC,mBAAmB,QAAnBA,mBAAmB;QAClC,IAAMC,OAAO,GAAG,SAAVA,OAAO,CAAIf,MAAM,EAAEgB,aAAa,EAAK;UAC1C,IAAIA,aAAa,CAACC,IAAI,KAAK,KAAK,EAAE;UAElC,IAAIC,YAAY,GAAG1B,OAAO;UAC1B,IAAIwB,aAAa,CAACC,IAAI,EAAE;YACvBC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEF,YAAY,EAAEF,aAAa,CAACC,IAAI,CAAC;UACnE;UACA,IAAIC,YAAY,CAACG,MAAM,EAAE;YACxBrB,MAAM,CAACG,KAAK,CAACC,UAAU,CACrBC,GAAG,CAAC,QAAQ,CAAC,CACbC,GAAG,CAAC,kBAAkB,EAAE,YAAM;cAC9B,IAAMgB,oBAAoB,GAAGlC,aAAa,CAACsB,uBAAuB,CACjEV,MAAM,CAACO,KAAK,CAACjB,MAAM,CAACqB,OAAO,EAC3BxB,OAAO,CAACW,OAAO,CAAC,sBAAsB,CAAC,CACvC;cACD,OAAOV,aAAa,CAACwB,yBAAyB,CAC7CZ,MAAM,EACN,QAAQ,EACRsB,oBAAoB,CACpB;YACF,CAAC,CAAC;UACJ;UACA,IAAIJ,YAAY,CAACK,OAAO,EAAE;YACzB,IAAMC,WAAW,GAAGN,YAAY,CAACK,OAAO;YACxCxB,aAAa,CAACC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAEwB,WAAW,CAAC;UACzD;UACA,IAAIN,YAAY,CAACO,OAAO,EAAE;YACzB,IAAMC,WAAW,GAAGR,YAAY,CAACO,OAAO;YACxC1B,aAAa,CAACC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE0B,WAAW,CAAC;UACzD;UACA,IAAMC,UAAU,GAAGT,YAAY,CAACU,MAAM;UACtC,IAAID,UAAU,EAAE;YACf5B,aAAa,CAACC,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE2B,UAAU,EAAE,SAAS,CAAC;UACjE;UACA,IAAIT,YAAY,CAACW,YAAY,EAAE;YAC9B,IAAMC,gBAAgB,GAAGZ,YAAY,CAACW,YAAY;YAClD9B,aAAa,CACZC,MAAM,EACN,cAAc,EACd,QAAQ,EACR8B,gBAAgB,EAChB,eAAe,CACf;YACD/B,aAAa,CACZC,MAAM,EACN,gBAAgB,EAChB,QAAQ,EACR8B,gBAAgB,EAChB,iBAAiB,CACjB;UACF;QACD,CAAC;QACDhB,mBAAmB,CAACX,KAAK,CAACH,MAAM,CAC9BK,GAAG,CAAC,iBAAiB,CAAC,CACtBC,GAAG,CAAC,kBAAkB,EAAES,OAAO,CAAC;QAClCD,mBAAmB,CAACX,KAAK,CAACH,MAAM,CAC9BK,GAAG,CAAC,oBAAoB,CAAC,CACzBC,GAAG,CAAC,kBAAkB,EAAES,OAAO,CAAC;MACnC,CAAC,CACD;MACDtB,QAAQ,CAACU,KAAK,CAAC4B,cAAc,CAACzB,GAAG,CAAC,kBAAkB,EAAE,UAAAb,QAAQ,EAAI;QAAA;UAC5D,IAAMuC,GAAG;UACb,IAAIxC,OAAO,CAACwC,GAAG,CAAC,KAAK,KAAK,EAAE;YAC3BvC,QAAQ,CAACwC,eAAe,CAAC9B,KAAK,CAAC+B,QAAQ,CACrC7B,GAAG,CAAC,QAAQ,CAAC,CACbC,GAAG,CAAC,kBAAkB,EAAE,UAAA4B,QAAQ,EAAI;cACpC,IAAIhD,WAAW,CACd,mBAAmB,EACnB;gBACCe,IAAI,EAAE+B,GAAG;gBACTG,UAAU,EAAE,IAAI;gBAChBC,KAAK,EAAE1C,eAAe,CAACsC,GAAG,EAAExC,OAAO,CAACwC,GAAG,CAAC;cACzC,CAAC,EACD,SAAS,CACT,CAACK,KAAK,CAACH,QAAQ,CAAC;YAClB,CAAC,CAAC;UACJ;QAAC;QAfF,gCAAkBf,MAAM,CAACmB,IAAI,CAACjD,eAAe,CAAC,kCAAE;UAAA;QAgBhD;MACD,CAAC,CAAC;IACH;EAAC;EAAA;AAAA,GACD"},"metadata":{},"sourceType":"script"}