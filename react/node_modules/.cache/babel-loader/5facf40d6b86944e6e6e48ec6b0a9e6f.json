{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nvar GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nvar bySetSize = function bySetSize(a, b) {\n  return b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nvar extraceBlockInfoMap = function extraceBlockInfoMap(compilation) {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  var blockInfoMap = new Map();\n\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n  var iteratorDependency = function iteratorDependency(d) {\n    // We skip Dependencies without Reference\n    var ref = compilation.getDependencyReference(currentModule, d);\n    if (!ref) {\n      return;\n    }\n    // We skip Dependencies without Module pointer\n    var refModule = ref.module;\n    if (!refModule) {\n      return;\n    }\n    // We skip weak Dependencies\n    if (ref.weak) {\n      return;\n    }\n    blockInfoModules.add(refModule);\n  };\n\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n  var iteratorBlockPrepare = function iteratorBlockPrepare(b) {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n\n  /** @type {Module} */\n  var currentModule;\n  /** @type {DependenciesBlock} */\n  var block;\n  /** @type {DependenciesBlock[]} */\n  var blockQueue;\n  /** @type {Set<Module>} */\n  var blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n  var blockInfoBlocks;\n  var _iterator = _createForOfIteratorHelper(compilation.modules),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _module = _step.value;\n      blockQueue = [_module];\n      currentModule = _module;\n      while (blockQueue.length > 0) {\n        block = blockQueue.pop();\n        blockInfoModules = new Set();\n        blockInfoBlocks = [];\n        if (block.variables) {\n          var _iterator2 = _createForOfIteratorHelper(block.variables),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var variable = _step2.value;\n              var _iterator3 = _createForOfIteratorHelper(variable.dependencies),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var dep = _step3.value;\n                  iteratorDependency(dep);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        if (block.dependencies) {\n          var _iterator4 = _createForOfIteratorHelper(block.dependencies),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep = _step4.value;\n              iteratorDependency(_dep);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        if (block.blocks) {\n          var _iterator5 = _createForOfIteratorHelper(block.blocks),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var b = _step5.value;\n              iteratorBlockPrepare(b);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n        var blockInfo = {\n          modules: blockInfoModules,\n          blocks: blockInfoBlocks\n        };\n        blockInfoMap.set(block, blockInfo);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nvar visitModules = function visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) {\n  var logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  var namedChunkGroups = compilation.namedChunkGroups;\n  logger.time(\"prepare\");\n  var blockInfoMap = extraceBlockInfoMap(compilation);\n\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n  var chunkGroupCounters = new Map();\n  var _iterator6 = _createForOfIteratorHelper(inputChunkGroups),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _chunkGroup3 = _step6.value;\n      chunkGroupCounters.set(_chunkGroup3, {\n        index: 0,\n        index2: 0\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  var nextFreeModuleIndex = 0;\n  var nextFreeModuleIndex2 = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n  var blockChunkGroups = new Map();\n  var ADD_AND_ENTER_MODULE = 0;\n  var ENTER_MODULE = 1;\n  var PROCESS_BLOCK = 2;\n  var LEAVE_MODULE = 3;\n\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n  var reduceChunkGroupToQueueItem = function reduceChunkGroupToQueueItem(queue, chunkGroup) {\n    var _iterator7 = _createForOfIteratorHelper(chunkGroup.chunks),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _chunk = _step7.value;\n        var _module2 = _chunk.entryModule;\n        queue.push({\n          action: ENTER_MODULE,\n          block: _module2,\n          module: _module2,\n          chunk: _chunk,\n          chunkGroup: chunkGroup\n        });\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup: chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  };\n\n  // Start with the provided modules/chunks\n  /** @type {QueueItem[]} */\n  var queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n  var queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  var outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n  var queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n\n  /** @type {Module} */\n  var module;\n  /** @type {Chunk} */\n  var chunk;\n  /** @type {ChunkGroup} */\n  var chunkGroup;\n  /** @type {ChunkGroupInfo} */\n  var chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n  var block;\n  /** @type {Set<Module>} */\n  var minAvailableModules;\n  /** @type {QueueItem[]} */\n  var skippedItems;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  var iteratorBlock = function iteratorBlock(b) {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    var c = blockChunkGroups.get(b);\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    }\n\n    // 2. We store the connection for the block\n    // to connect it later if needed\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    });\n\n    // 3. We create/update the chunk group info\n    var connectList = queueConnect.get(chunkGroup);\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n    connectList.add(c);\n\n    // 4. We enqueue the DependenciesBlock for traversal\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length) {\n    logger.time(\"visiting\");\n    while (queue.length) {\n      var queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            }\n            // We connect Module and Chunk when not already done\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var index = chunkGroup.getModuleIndex(module);\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n            queue.push({\n              action: LEAVE_MODULE,\n              block: block,\n              module: module,\n              chunk: chunk,\n              chunkGroup: chunkGroup\n            });\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            var blockInfo = blockInfoMap.get(block);\n\n            // Buffer items because order need to be reverse to get indicies correct\n            var skipBuffer = [];\n            var queueBuffer = [];\n            // Traverse all referenced modules\n            var _iterator8 = _createForOfIteratorHelper(blockInfo.modules),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var refModule = _step8.value;\n                if (chunk.containsModule(refModule)) {\n                  // skip early if already connected\n                  continue;\n                }\n                if (minAvailableModules.has(refModule)) {\n                  // already in parent chunks, skip it for now\n                  skipBuffer.push({\n                    action: ADD_AND_ENTER_MODULE,\n                    block: refModule,\n                    module: refModule,\n                    chunk: chunk,\n                    chunkGroup: chunkGroup\n                  });\n                  continue;\n                }\n                // enqueue the add and enter to enter in the correct order\n                // this is relevant with circular dependencies\n                queueBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk: chunk,\n                  chunkGroup: chunkGroup\n                });\n              }\n              // Add buffered items in reversed order\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n            for (var i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n            for (var _i = queueBuffer.length - 1; _i >= 0; _i--) {\n              queue.push(queueBuffer[_i]);\n            }\n\n            // Traverse all Blocks\n            var _iterator9 = _createForOfIteratorHelper(blockInfo.blocks),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _block = _step9.value;\n                iteratorBlock(_block);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var _index = chunkGroup.getModuleIndex2(module);\n              if (_index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n            break;\n          }\n      }\n    }\n    logger.timeEnd(\"visiting\");\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\");\n\n      // Figure out new parents for chunk groups\n      // to get new available modules for these children\n      var _iterator10 = _createForOfIteratorHelper(queueConnect),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n            _chunkGroup2 = _step10$value[0],\n            targets = _step10$value[1];\n          var _info = chunkGroupInfoMap.get(_chunkGroup2);\n          var _minAvailableModules = _info.minAvailableModules;\n\n          // 1. Create a new Set of available modules at this points\n          var resultingAvailableModules = new Set(_minAvailableModules);\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _chunk2 = _step17.value;\n              var _iterator20 = _createForOfIteratorHelper(_chunk2.modulesIterable),\n                _step20;\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _m2 = _step20.value;\n                  resultingAvailableModules.add(_m2);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n          _info.resultingAvailableModules = resultingAvailableModules;\n          if (_info.children === undefined) {\n            _info.children = targets;\n          } else {\n            var _iterator18 = _createForOfIteratorHelper(targets),\n              _step18;\n            try {\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                var target = _step18.value;\n                _info.children.add(target);\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n          }\n\n          // 2. Update chunk group info\n          var _iterator19 = _createForOfIteratorHelper(targets),\n            _step19;\n          try {\n            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n              var _target = _step19.value;\n              var _chunkGroupInfo = chunkGroupInfoMap.get(_target);\n              if (_chunkGroupInfo === undefined) {\n                _chunkGroupInfo = {\n                  chunkGroup: _target,\n                  minAvailableModules: undefined,\n                  minAvailableModulesOwned: undefined,\n                  availableModulesToBeMerged: [],\n                  skippedItems: [],\n                  resultingAvailableModules: undefined,\n                  children: undefined\n                };\n                chunkGroupInfoMap.set(_target, _chunkGroupInfo);\n              }\n              _chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n              outdatedChunkGroupInfo.add(_chunkGroupInfo);\n            }\n          } catch (err) {\n            _iterator19.e(err);\n          } finally {\n            _iterator19.f();\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\");\n        // Execute the merge\n        var _iterator11 = _createForOfIteratorHelper(outdatedChunkGroupInfo),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var info = _step11.value;\n            var availableModulesToBeMerged = info.availableModulesToBeMerged;\n            var cachedMinAvailableModules = info.minAvailableModules;\n\n            // 1. Get minimal available modules\n            // It doesn't make sense to traverse a chunk again with more available modules.\n            // This step calculates the minimal available modules and skips traversal when\n            // the list didn't shrink.\n            if (availableModulesToBeMerged.length > 1) {\n              availableModulesToBeMerged.sort(bySetSize);\n            }\n            var changed = false;\n            var _iterator12 = _createForOfIteratorHelper(availableModulesToBeMerged),\n              _step12;\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var availableModules = _step12.value;\n                if (cachedMinAvailableModules === undefined) {\n                  cachedMinAvailableModules = availableModules;\n                  info.minAvailableModules = cachedMinAvailableModules;\n                  info.minAvailableModulesOwned = false;\n                  changed = true;\n                } else {\n                  if (info.minAvailableModulesOwned) {\n                    // We own it and can modify it\n                    var _iterator15 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                      _step15;\n                    try {\n                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                        var m = _step15.value;\n                        if (!availableModules.has(m)) {\n                          cachedMinAvailableModules.delete(m);\n                          changed = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator15.e(err);\n                    } finally {\n                      _iterator15.f();\n                    }\n                  } else {\n                    var _iterator16 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                      _step16;\n                    try {\n                      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                        var _m = _step16.value;\n                        if (!availableModules.has(_m)) {\n                          // cachedMinAvailableModules need to be modified\n                          // but we don't own it\n                          // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                          /** @type {Set<Module>} */\n                          var newSet = new Set();\n                          var iterator = cachedMinAvailableModules[Symbol.iterator]();\n                          /** @type {IteratorResult<Module>} */\n                          var it = void 0;\n                          while (!(it = iterator.next()).done) {\n                            var _module3 = it.value;\n                            if (_module3 === _m) break;\n                            newSet.add(_module3);\n                          }\n                          while (!(it = iterator.next()).done) {\n                            var _module4 = it.value;\n                            if (availableModules.has(_module4)) {\n                              newSet.add(_module4);\n                            }\n                          }\n                          cachedMinAvailableModules = newSet;\n                          info.minAvailableModulesOwned = true;\n                          info.minAvailableModules = newSet;\n\n                          // Update the cache from the first queue\n                          // if the chunkGroup is currently cached\n                          if (chunkGroup === info.chunkGroup) {\n                            minAvailableModules = cachedMinAvailableModules;\n                          }\n                          changed = true;\n                          break;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator16.e(err);\n                    } finally {\n                      _iterator16.f();\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n            availableModulesToBeMerged.length = 0;\n            if (!changed) continue;\n\n            // 2. Reconsider skipped items\n            var _iterator13 = _createForOfIteratorHelper(info.skippedItems),\n              _step13;\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _queueItem = _step13.value;\n                queue.push(_queueItem);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n            info.skippedItems.length = 0;\n\n            // 3. Reconsider children chunk groups\n            if (info.children !== undefined) {\n              var _chunkGroup = info.chunkGroup;\n              var _iterator14 = _createForOfIteratorHelper(info.children),\n                _step14;\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var c = _step14.value;\n                  var connectList = queueConnect.get(_chunkGroup);\n                  if (connectList === undefined) {\n                    connectList = new Set();\n                    queueConnect.set(_chunkGroup, connectList);\n                  }\n                  connectList.add(c);\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      var tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nvar connectChunkGroups = function connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {\n    var _iterator21 = _createForOfIteratorHelper(chunkGroup.chunks),\n      _step21;\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var chunk = _step21.value;\n        var _iterator22 = _createForOfIteratorHelper(chunk.modulesIterable),\n          _step22;\n        try {\n          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n            var _module5 = _step22.value;\n            if (!availableModules.has(_module5)) return false;\n          }\n        } catch (err) {\n          _iterator22.e(err);\n        } finally {\n          _iterator22.f();\n        }\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  var _iterator23 = _createForOfIteratorHelper(blockConnections),\n    _step23;\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var _step23$value = _slicedToArray(_step23.value, 2),\n        block = _step23$value[0],\n        connections = _step23$value[1];\n      // 1. Check if connection is needed\n      // When none of the dependencies need to be connected\n      // we can skip all of them\n      // It's not possible to filter each item so it doesn't create inconsistent\n      // connections and modules can only create one version\n      // TODO maybe decide this per runtime\n      if (\n      // TODO is this needed?\n      !blocksWithNestedBlocks.has(block) && connections.every(function (_ref) {\n        var chunkGroup = _ref.chunkGroup,\n          originChunkGroupInfo = _ref.originChunkGroupInfo;\n        return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n      })) {\n        continue;\n      }\n\n      // 2. Foreach edge\n      for (var i = 0; i < connections.length; i++) {\n        var _connections$i = connections[i],\n          chunkGroup = _connections$i.chunkGroup,\n          originChunkGroupInfo = _connections$i.originChunkGroupInfo;\n\n        // 3. Connect block with chunk\n        GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n        // 4. Connect chunk with parent\n        GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nvar cleanupUnconnectedGroups = function cleanupUnconnectedGroups(compilation, allCreatedChunkGroups) {\n  var _iterator24 = _createForOfIteratorHelper(allCreatedChunkGroups),\n    _step24;\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var chunkGroup = _step24.value;\n      if (chunkGroup.getNumberOfParents() === 0) {\n        var _iterator25 = _createForOfIteratorHelper(chunkGroup.chunks),\n          _step25;\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var chunk = _step25.value;\n            var idx = compilation.chunks.indexOf(chunk);\n            if (idx >= 0) compilation.chunks.splice(idx, 1);\n            chunk.remove(\"unconnected\");\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n        chunkGroup.remove(\"unconnected\");\n      }\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nvar buildChunkGraph = function buildChunkGraph(compilation, inputChunkGroups) {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  var blockConnections = new Map();\n\n  /** @type {Set<ChunkGroup>} */\n  var allCreatedChunkGroups = new Set();\n\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n  var chunkGroupInfoMap = new Map();\n\n  /** @type {Set<DependenciesBlock>} */\n  var blocksWithNestedBlocks = new Set();\n\n  // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n\n  // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n\n  // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","GraphHelpers","bySetSize","a","b","size","extraceBlockInfoMap","compilation","blockInfoMap","Map","iteratorDependency","d","ref","getDependencyReference","currentModule","refModule","module","weak","blockInfoModules","add","iteratorBlockPrepare","blockInfoBlocks","push","blockQueue","block","modules","length","pop","Set","variables","variable","dependencies","dep","blocks","blockInfo","set","visitModules","inputChunkGroups","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","logger","getLogger","namedChunkGroups","time","chunkGroupCounters","chunkGroup","index","index2","nextFreeModuleIndex","nextFreeModuleIndex2","blockChunkGroups","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","LEAVE_MODULE","reduceChunkGroupToQueueItem","queue","chunks","chunk","entryModule","action","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","undefined","children","reduce","reverse","queueConnect","outdatedChunkGroupInfo","queueDelayed","timeEnd","chunkGroupInfo","iteratorBlock","c","get","chunkName","isInitial","errors","loc","addChunkInGroup","groupOptions","request","addOptions","addOrigin","originChunkGroupInfo","connectList","queueItem","has","addModule","addChunk","getModuleIndex","setModuleIndex","skipBuffer","queueBuffer","containsModule","i","getModuleIndex2","setModuleIndex2","targets","info","modulesIterable","m","target","clear","cachedMinAvailableModules","sort","changed","availableModules","delete","newSet","iterator","Symbol","it","next","done","value","tempQueue","connectChunkGroups","areModulesAvailable","connections","every","connectDependenciesBlockAndChunkGroup","connectChunkGroupParentAndChild","cleanupUnconnectedGroups","getNumberOfParents","idx","indexOf","splice","remove","buildChunkGraph","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n\t/** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n\tconst blockInfoMap = new Map();\n\n\t/**\n\t * @param {Dependency} d dependency to iterate over\n\t * @returns {void}\n\t */\n\tconst iteratorDependency = d => {\n\t\t// We skip Dependencies without Reference\n\t\tconst ref = compilation.getDependencyReference(currentModule, d);\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip Dependencies without Module pointer\n\t\tconst refModule = ref.module;\n\t\tif (!refModule) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip weak Dependencies\n\t\tif (ref.weak) {\n\t\t\treturn;\n\t\t}\n\n\t\tblockInfoModules.add(refModule);\n\t};\n\n\t/**\n\t * @param {AsyncDependenciesBlock} b blocks to prepare\n\t * @returns {void}\n\t */\n\tconst iteratorBlockPrepare = b => {\n\t\tblockInfoBlocks.push(b);\n\t\tblockQueue.push(b);\n\t};\n\n\t/** @type {Module} */\n\tlet currentModule;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {DependenciesBlock[]} */\n\tlet blockQueue;\n\t/** @type {Set<Module>} */\n\tlet blockInfoModules;\n\t/** @type {AsyncDependenciesBlock[]} */\n\tlet blockInfoBlocks;\n\n\tfor (const module of compilation.modules) {\n\t\tblockQueue = [module];\n\t\tcurrentModule = module;\n\t\twhile (blockQueue.length > 0) {\n\t\t\tblock = blockQueue.pop();\n\t\t\tblockInfoModules = new Set();\n\t\t\tblockInfoBlocks = [];\n\n\t\t\tif (block.variables) {\n\t\t\t\tfor (const variable of block.variables) {\n\t\t\t\t\tfor (const dep of variable.dependencies) iteratorDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\tfor (const dep of block.dependencies) iteratorDependency(dep);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\tfor (const b of block.blocks) iteratorBlockPrepare(b);\n\t\t\t}\n\n\t\t\tconst blockInfo = {\n\t\t\t\tmodules: blockInfoModules,\n\t\t\t\tblocks: blockInfoBlocks\n\t\t\t};\n\t\t\tblockInfoMap.set(block, blockInfo);\n\t\t}\n\t}\n\n\treturn blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tcompilation,\n\tinputChunkGroups,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n\tconst { namedChunkGroups } = compilation;\n\n\tlogger.time(\"prepare\");\n\tconst blockInfoMap = extraceBlockInfoMap(compilation);\n\n\t/** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\tconst chunkGroupCounters = new Map();\n\tfor (const chunkGroup of inputChunkGroups) {\n\t\tchunkGroupCounters.set(chunkGroup, {\n\t\t\tindex: 0,\n\t\t\tindex2: 0\n\t\t});\n\t}\n\n\tlet nextFreeModuleIndex = 0;\n\tlet nextFreeModuleIndex2 = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroup>} */\n\tconst blockChunkGroups = new Map();\n\n\tconst ADD_AND_ENTER_MODULE = 0;\n\tconst ENTER_MODULE = 1;\n\tconst PROCESS_BLOCK = 2;\n\tconst LEAVE_MODULE = 3;\n\n\t/**\n\t * @param {QueueItem[]} queue the queue array (will be mutated)\n\t * @param {ChunkGroup} chunkGroup chunk group\n\t * @returns {QueueItem[]} the queue array again\n\t */\n\tconst reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst module = chunk.entryModule;\n\t\t\tqueue.push({\n\t\t\t\taction: ENTER_MODULE,\n\t\t\t\tblock: module,\n\t\t\t\tmodule,\n\t\t\t\tchunk,\n\t\t\t\tchunkGroup\n\t\t\t});\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, {\n\t\t\tchunkGroup,\n\t\t\tminAvailableModules: new Set(),\n\t\t\tminAvailableModulesOwned: true,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: [],\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t\treturn queue;\n\t};\n\n\t// Start with the provided modules/chunks\n\t/** @type {QueueItem[]} */\n\tlet queue = inputChunkGroups\n\t\t.reduce(reduceChunkGroupToQueueItem, [])\n\t\t.reverse();\n\t/** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\tlogger.timeEnd(\"prepare\");\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {Set<Module>} */\n\tlet minAvailableModules;\n\t/** @type {QueueItem[]} */\n\tlet skippedItems;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet c = blockChunkGroups.get(b);\n\t\tif (c === undefined) {\n\t\t\tc = namedChunkGroups.get(b.chunkName);\n\t\t\tif (c && c.isInitial()) {\n\t\t\t\tcompilation.errors.push(\n\t\t\t\t\tnew AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)\n\t\t\t\t);\n\t\t\t\tc = chunkGroup;\n\t\t\t} else {\n\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\tmodule,\n\t\t\t\t\tb.loc,\n\t\t\t\t\tb.request\n\t\t\t\t);\n\t\t\t\tchunkGroupCounters.set(c, { index: 0, index2: 0 });\n\t\t\t\tblockChunkGroups.set(b, c);\n\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t}\n\t\t\tblockConnections.set(b, []);\n\t\t} else {\n\t\t\t// TODO webpack 5 remove addOptions check\n\t\t\tif (c.addOptions) c.addOptions(b.groupOptions);\n\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t}\n\n\t\t// 2. We store the connection for the block\n\t\t// to connect it later if needed\n\t\tblockConnections.get(b).push({\n\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\tchunkGroup: c\n\t\t});\n\n\t\t// 3. We create/update the chunk group info\n\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\tif (connectList === undefined) {\n\t\t\tconnectList = new Set();\n\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t}\n\t\tconnectList.add(c);\n\n\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\tqueueDelayed.push({\n\t\t\taction: PROCESS_BLOCK,\n\t\t\tblock: b,\n\t\t\tmodule: module,\n\t\t\tchunk: c.chunks[0],\n\t\t\tchunkGroup: c\n\t\t});\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length) {\n\t\tlogger.time(\"visiting\");\n\t\twhile (queue.length) {\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tif (chunkGroup !== queueItem.chunkGroup) {\n\t\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\t\tchunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tminAvailableModules = chunkGroupInfo.minAvailableModules;\n\t\t\t\tskippedItems = chunkGroupInfo.skippedItems;\n\t\t\t}\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (minAvailableModules.has(module)) {\n\t\t\t\t\t\t// already in parent chunks\n\t\t\t\t\t\t// skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n\t\t\t\t\t\tskippedItems.push(queueItem);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk when not already done\n\t\t\t\t\tif (chunk.addModule(module)) {\n\t\t\t\t\t\tmodule.addChunk(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index === null) {\n\t\t\t\t\t\tmodule.index = nextFreeModuleIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: LEAVE_MODULE,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\t// get prepared block info\n\t\t\t\t\tconst blockInfo = blockInfoMap.get(block);\n\n\t\t\t\t\t// Buffer items because order need to be reverse to get indicies correct\n\t\t\t\t\tconst skipBuffer = [];\n\t\t\t\t\tconst queueBuffer = [];\n\t\t\t\t\t// Traverse all referenced modules\n\t\t\t\t\tfor (const refModule of blockInfo.modules) {\n\t\t\t\t\t\tif (chunk.containsModule(refModule)) {\n\t\t\t\t\t\t\t// skip early if already connected\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (minAvailableModules.has(refModule)) {\n\t\t\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\t\t\tskipBuffer.push({\n\t\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// enqueue the add and enter to enter in the correct order\n\t\t\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\t\t\tqueueBuffer.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Add buffered items in reversed order\n\t\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tskippedItems.push(skipBuffer[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Traverse all Blocks\n\t\t\t\t\tfor (const block of blockInfo.blocks) iteratorBlock(block);\n\n\t\t\t\t\tif (blockInfo.blocks.length > 0 && module !== block) {\n\t\t\t\t\t\tblocksWithNestedBlocks.add(block);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex2(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex2(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index2++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index2 === null) {\n\t\t\t\t\t\tmodule.index2 = nextFreeModuleIndex2++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.timeEnd(\"visiting\");\n\n\t\twhile (queueConnect.size > 0) {\n\t\t\tlogger.time(\"calculating available modules\");\n\n\t\t\t// Figure out new parents for chunk groups\n\t\t\t// to get new available modules for these children\n\t\t\tfor (const [chunkGroup, targets] of queueConnect) {\n\t\t\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tlet minAvailableModules = info.minAvailableModules;\n\n\t\t\t\t// 1. Create a new Set of available modules at this points\n\t\t\t\tconst resultingAvailableModules = new Set(minAvailableModules);\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo.resultingAvailableModules = resultingAvailableModules;\n\t\t\t\tif (info.children === undefined) {\n\t\t\t\t\tinfo.children = targets;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const target of targets) {\n\t\t\t\t\t\tinfo.children.add(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. Update chunk group info\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tlet chunkGroupInfo = chunkGroupInfoMap.get(target);\n\t\t\t\t\tif (chunkGroupInfo === undefined) {\n\t\t\t\t\t\tchunkGroupInfo = {\n\t\t\t\t\t\t\tchunkGroup: target,\n\t\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\t\tskippedItems: [],\n\t\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tchunkGroupInfoMap.set(target, chunkGroupInfo);\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupInfo.availableModulesToBeMerged.push(\n\t\t\t\t\t\tresultingAvailableModules\n\t\t\t\t\t);\n\t\t\t\t\toutdatedChunkGroupInfo.add(chunkGroupInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueueConnect.clear();\n\t\t\tlogger.timeEnd(\"calculating available modules\");\n\n\t\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\t\tlogger.time(\"merging available modules\");\n\t\t\t\t// Execute the merge\n\t\t\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\t\t\t// 1. Get minimal available modules\n\t\t\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t\t\t// the list didn't shrink.\n\t\t\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t\t\t}\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\t\t\tconst newSet = new Set();\n\t\t\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[\n\t\t\t\t\t\t\t\t\t\t\tSymbol.iterator\n\t\t\t\t\t\t\t\t\t\t]();\n\t\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\n\t\t\t\t\t\t\t\t\t\t// Update the cache from the first queue\n\t\t\t\t\t\t\t\t\t\t// if the chunkGroup is currently cached\n\t\t\t\t\t\t\t\t\t\tif (chunkGroup === info.chunkGroup) {\n\t\t\t\t\t\t\t\t\t\t\tminAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\t\t\tif (!changed) continue;\n\n\t\t\t\t\t// 2. Reconsider skipped items\n\t\t\t\t\tfor (const queueItem of info.skippedItems) {\n\t\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.skippedItems.length = 0;\n\n\t\t\t\t\t// 3. Reconsider children chunk groups\n\t\t\t\t\tif (info.children !== undefined) {\n\t\t\t\t\t\tconst chunkGroup = info.chunkGroup;\n\t\t\t\t\t\tfor (const c of info.children) {\n\t\t\t\t\t\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\t\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnectList.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toutdatedChunkGroupInfo.clear();\n\t\t\t\tlogger.timeEnd(\"merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indicing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {Set<Module>} availableModules the comparitor set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (!availableModules.has(module)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tGraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tGraphHelpers.connectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tconst idx = compilation.chunks.indexOf(chunk);\n\t\t\t\tif (idx >= 0) compilation.chunks.splice(idx, 1);\n\t\t\t\tchunk.remove(\"unconnected\");\n\t\t\t}\n\t\t\tchunkGroup.remove(\"unconnected\");\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tvisitModules(\n\t\tcompilation,\n\t\tinputChunkGroups,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\n\t// PART TWO\n\n\tconnectChunkGroups(\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\n\t// Cleaup work\n\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}