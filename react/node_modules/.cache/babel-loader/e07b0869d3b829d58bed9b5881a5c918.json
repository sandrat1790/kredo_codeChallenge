{"ast":null,"code":"/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar util = require(\"util\");\nvar SortableSet = require(\"./util/SortableSet\");\nvar intersect = require(\"./util/SetHelpers\").intersect;\nvar GraphHelpers = require(\"./GraphHelpers\");\nvar Entrypoint = require(\"./Entrypoint\");\nvar debugId = 1000;\nvar ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nvar ERR_CHUNK_INITIAL = \"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nvar sortModuleById = function sortModuleById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nvar sortChunkGroupById = function sortChunkGroupById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nvar _getModulesIdent = function getModulesIdent(set) {\n  set.sort();\n  var str = \"\";\n  var _iterator = _createForOfIteratorHelper(set),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var m = _step.value;\n      str += m.identifier() + \"#\";\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nvar getModulesSize = function getModulesSize(set) {\n  var size = 0;\n  var _iterator2 = _createForOfIteratorHelper(set),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _module = _step2.value;\n      size += _module.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nvar Chunk = /*#__PURE__*/function () {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   */\n  function Chunk(name) {\n    _classCallCheck(this, Chunk);\n    /** @type {number | null} */\n    this.id = null;\n    /** @type {number[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {Module=} */\n    this.entryModule = undefined;\n    /** @private @type {SortableSet<Module>} */\n    this._modules = new SortableSet(undefined, sortByIdentifier);\n    /** @type {string?} */\n    this.filenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, sortChunkGroupById);\n    /** @type {string[]} */\n    this.files = [];\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Object} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n    this.removedModules = undefined;\n  }\n\n  /**\n   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n   * @returns {never} Throws an error trying to access this property\n   */\n  _createClass(Chunk, [{\n    key: \"entry\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n\n    /**\n     * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n     * @param {never} data The data that was attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @returns {never} Throws an error trying to access this property\n     */\n  }, {\n    key: \"initial\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @param {never} data The data attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n\n    /**\n     * @returns {boolean} whether or not the Chunk will have a runtime\n     */\n  }, {\n    key: \"hasRuntime\",\n    value: function hasRuntime() {\n      var _iterator3 = _createForOfIteratorHelper(this._groups),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var chunkGroup = _step3.value;\n          if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} whether or not this chunk can be an initial chunk\n     */\n  }, {\n    key: \"canBeInitial\",\n    value: function canBeInitial() {\n      var _iterator4 = _createForOfIteratorHelper(this._groups),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var chunkGroup = _step4.value;\n          if (chunkGroup.isInitial()) return true;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} whether this chunk can only be an initial chunk\n     */\n  }, {\n    key: \"isOnlyInitial\",\n    value: function isOnlyInitial() {\n      if (this._groups.size <= 0) return false;\n      var _iterator5 = _createForOfIteratorHelper(this._groups),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var chunkGroup = _step5.value;\n          if (!chunkGroup.isInitial()) return false;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return true;\n    }\n\n    /**\n     * @returns {boolean} if this chunk contains the entry module\n     */\n  }, {\n    key: \"hasEntryModule\",\n    value: function hasEntryModule() {\n      return !!this.entryModule;\n    }\n\n    /**\n     * @param {Module} module the module that will be added to this chunk.\n     * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n     */\n  }, {\n    key: \"addModule\",\n    value: function addModule(module) {\n      if (!this._modules.has(module)) {\n        this._modules.add(module);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {Module} module the module that will be removed from this chunk\n     * @returns {boolean} returns true if chunk exists and is successfully deleted\n     */\n  }, {\n    key: \"removeModule\",\n    value: function removeModule(module) {\n      if (this._modules.delete(module)) {\n        module.removeChunk(this);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {Module[]} modules the new modules to be set\n     * @returns {void} set new modules to this chunk and return nothing\n     */\n  }, {\n    key: \"setModules\",\n    value: function setModules(modules) {\n      this._modules = new SortableSet(modules, sortByIdentifier);\n    }\n\n    /**\n     * @returns {number} the amount of modules in chunk\n     */\n  }, {\n    key: \"getNumberOfModules\",\n    value: function getNumberOfModules() {\n      return this._modules.size;\n    }\n\n    /**\n     * @returns {SortableSet} return the modules SortableSet for this chunk\n     */\n  }, {\n    key: \"modulesIterable\",\n    get: function get() {\n      return this._modules;\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n     * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n     */\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(chunkGroup) {\n      if (this._groups.has(chunkGroup)) return false;\n      this._groups.add(chunkGroup);\n      return true;\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n     * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n     */\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(chunkGroup) {\n      if (!this._groups.has(chunkGroup)) return false;\n      this._groups.delete(chunkGroup);\n      return true;\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup to check\n     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n     */\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(chunkGroup) {\n      return this._groups.has(chunkGroup);\n    }\n\n    /**\n     * @returns {number} the amount of groups said chunk is in\n     */\n  }, {\n    key: \"getNumberOfGroups\",\n    value: function getNumberOfGroups() {\n      return this._groups.size;\n    }\n\n    /**\n     * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n     */\n  }, {\n    key: \"groupsIterable\",\n    get: function get() {\n      return this._groups;\n    }\n\n    /**\n     * @param {Chunk} otherChunk the chunk to compare itself with\n     * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n     */\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(otherChunk) {\n      if (this.name && !otherChunk.name) return -1;\n      if (!this.name && otherChunk.name) return 1;\n      if (this.name < otherChunk.name) return -1;\n      if (this.name > otherChunk.name) return 1;\n      if (this._modules.size > otherChunk._modules.size) return -1;\n      if (this._modules.size < otherChunk._modules.size) return 1;\n      this._modules.sort();\n      otherChunk._modules.sort();\n      var a = this._modules[Symbol.iterator]();\n      var b = otherChunk._modules[Symbol.iterator]();\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        var aItem = a.next();\n        if (aItem.done) return 0;\n        var bItem = b.next();\n        var aModuleIdentifier = aItem.value.identifier();\n        var bModuleIdentifier = bItem.value.identifier();\n        if (aModuleIdentifier < bModuleIdentifier) return -1;\n        if (aModuleIdentifier > bModuleIdentifier) return 1;\n      }\n    }\n\n    /**\n     * @param {Module} module Module to check\n     * @returns {boolean} returns true if module does exist in this chunk\n     */\n  }, {\n    key: \"containsModule\",\n    value: function containsModule(module) {\n      return this._modules.has(module);\n    }\n\n    /**\n     * @returns {Module[]} an array of modules (do not modify)\n     */\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this._modules.getFromCache(getArray);\n    }\n  }, {\n    key: \"getModulesIdent\",\n    value: function getModulesIdent() {\n      return this._modules.getFromUnorderedCache(_getModulesIdent);\n    }\n\n    /**\n     * @param {string=} reason reason why chunk is removed\n     * @returns {void}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(reason) {\n      // cleanup modules\n      // Array.from is used here to create a clone, because removeChunk modifies this._modules\n      for (var _i = 0, _Array$from = Array.from(this._modules); _i < _Array$from.length; _i++) {\n        var _module2 = _Array$from[_i];\n        _module2.removeChunk(this);\n      }\n      var _iterator6 = _createForOfIteratorHelper(this._groups),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var chunkGroup = _step6.value;\n          chunkGroup.removeChunk(this);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n\n    /**\n     *\n     * @param {Module} module module to move\n     * @param {Chunk} otherChunk other chunk to move it to\n     * @returns {void}\n     */\n  }, {\n    key: \"moveModule\",\n    value: function moveModule(module, otherChunk) {\n      GraphHelpers.disconnectChunkAndModule(this, module);\n      GraphHelpers.connectChunkAndModule(otherChunk, module);\n      module.rewriteChunkInReasons(this, [otherChunk]);\n    }\n\n    /**\n     *\n     * @param {Chunk} otherChunk the chunk to integrate with\n     * @param {string} reason reason why the module is being integrated\n     * @returns {boolean} returns true or false if integration succeeds or fails\n     */\n  }, {\n    key: \"integrate\",\n    value: function integrate(otherChunk, reason) {\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      }\n\n      // Pick a new name for the integrated chunk\n      if (this.name && otherChunk.name) {\n        if (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n          // When both chunks have entry modules or none have one, use\n          // shortest name\n          if (this.name.length !== otherChunk.name.length) {\n            this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;\n          } else {\n            this.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n          }\n        } else if (otherChunk.hasEntryModule()) {\n          // Pick the name of the chunk with the entry module\n          this.name = otherChunk.name;\n        }\n      } else if (otherChunk.name) {\n        this.name = otherChunk.name;\n      }\n\n      // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n      for (var _i2 = 0, _Array$from2 = Array.from(otherChunk._modules); _i2 < _Array$from2.length; _i2++) {\n        var _module3 = _Array$from2[_i2];\n        otherChunk.moveModule(_module3, this);\n      }\n      otherChunk._modules.clear();\n      if (otherChunk.entryModule) {\n        this.entryModule = otherChunk.entryModule;\n      }\n      var _iterator7 = _createForOfIteratorHelper(otherChunk._groups),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var chunkGroup = _step7.value;\n          chunkGroup.replaceChunk(otherChunk, this);\n          this.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      otherChunk._groups.clear();\n      return true;\n    }\n\n    /**\n     * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n     * @returns {void}\n     */\n  }, {\n    key: \"split\",\n    value: function split(newChunk) {\n      var _iterator8 = _createForOfIteratorHelper(this._groups),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var chunkGroup = _step8.value;\n          chunkGroup.insertChunk(newChunk, this);\n          newChunk.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._modules.size === 0;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id, \" \"));\n      hash.update(this.ids ? this.ids.join(\",\") : \"\");\n      hash.update(\"\".concat(this.name || \"\", \" \"));\n      var _iterator9 = _createForOfIteratorHelper(this._modules),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var m = _step9.value;\n          hash.update(m.hash);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }, {\n    key: \"canBeIntegrated\",\n    value: function canBeIntegrated(otherChunk) {\n      if (this.preventIntegration || otherChunk.preventIntegration) {\n        return false;\n      }\n\n      /**\n       * @param {Chunk} a chunk\n       * @param {Chunk} b chunk\n       * @returns {boolean} true, if a is always available when b is reached\n       */\n      var isAvailable = function isAvailable(a, b) {\n        var queue = new Set(b.groupsIterable);\n        var _iterator10 = _createForOfIteratorHelper(queue),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var chunkGroup = _step10.value;\n            if (a.isInGroup(chunkGroup)) continue;\n            if (chunkGroup.isInitial()) return false;\n            var _iterator11 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var parent = _step11.value;\n                queue.add(parent);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n        return true;\n      };\n      var selfHasRuntime = this.hasRuntime();\n      var otherChunkHasRuntime = otherChunk.hasRuntime();\n      if (selfHasRuntime !== otherChunkHasRuntime) {\n        if (selfHasRuntime) {\n          return isAvailable(this, otherChunk);\n        } else if (otherChunkHasRuntime) {\n          return isAvailable(otherChunk, this);\n        } else {\n          return false;\n        }\n      }\n      if (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     *\n     * @param {number} size the size\n     * @param {Object} options the options passed in\n     * @returns {number} the multiplier returned\n     */\n  }, {\n    key: \"addMultiplierAndOverhead\",\n    value: function addMultiplierAndOverhead(size, options) {\n      var overhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;\n      return size * multiplicator + overhead;\n    }\n\n    /**\n     * @returns {number} the size of all modules\n     */\n  }, {\n    key: \"modulesSize\",\n    value: function modulesSize() {\n      return this._modules.getFromUnorderedCache(getModulesSize);\n    }\n\n    /**\n     * @param {Object} options the size display options\n     * @returns {number} the chunk size\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.addMultiplierAndOverhead(this.modulesSize(), options);\n    }\n\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @param {TODO} options the options for this function\n     * @returns {number | false} the size, or false if it can't be integrated\n     */\n  }, {\n    key: \"integratedSize\",\n    value: function integratedSize(otherChunk, options) {\n      // Chunk if it's possible to integrate this chunk\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      }\n      var integratedModulesSize = this.modulesSize();\n      // only count modules that do not exist in this chunk!\n      var _iterator12 = _createForOfIteratorHelper(otherChunk._modules),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var otherModule = _step12.value;\n          if (!this._modules.has(otherModule)) {\n            integratedModulesSize += otherModule.size();\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      return this.addMultiplierAndOverhead(integratedModulesSize, options);\n    }\n\n    /**\n     * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n     * @returns {void}\n     */\n  }, {\n    key: \"sortModules\",\n    value: function sortModules(sortByFn) {\n      this._modules.sortWith(sortByFn || sortModuleById);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems() {\n      this.sortModules();\n    }\n\n    /**\n     * @returns {Set<Chunk>} a set of all the async chunks\n     */\n  }, {\n    key: \"getAllAsyncChunks\",\n    value: function getAllAsyncChunks() {\n      var queue = new Set();\n      var chunks = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n      var _iterator13 = _createForOfIteratorHelper(this.groupsIterable),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var chunkGroup = _step13.value;\n          var _iterator15 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step15;\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var child = _step15.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      var _iterator14 = _createForOfIteratorHelper(queue),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _chunkGroup = _step14.value;\n          var _iterator16 = _createForOfIteratorHelper(_chunkGroup.chunks),\n            _step16;\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var chunk = _step16.value;\n              if (!initialChunks.has(chunk)) {\n                chunks.add(chunk);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _child = _step17.value;\n              queue.add(_child);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      return chunks;\n    }\n\n    /**\n     * @typedef {Object} ChunkMaps\n     * @property {Record<string|number, string>} hash\n     * @property {Record<string|number, Record<string, string>>} contentHash\n     * @property {Record<string|number, string>} name\n     */\n\n    /**\n     * @param {boolean} realHash should the full hash or the rendered hash be used\n     * @returns {ChunkMaps} the chunk map information\n     */\n  }, {\n    key: \"getChunkMaps\",\n    value: function getChunkMaps(realHash) {\n      /** @type {Record<string|number, string>} */\n      var chunkHashMap = Object.create(null);\n      /** @type {Record<string|number, Record<string, string>>} */\n      var chunkContentHashMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n      var chunkNameMap = Object.create(null);\n      var _iterator18 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var chunk = _step18.value;\n          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n          for (var _i3 = 0, _Object$keys = Object.keys(chunk.contentHash); _i3 < _Object$keys.length; _i3++) {\n            var key = _Object$keys[_i3];\n            if (!chunkContentHashMap[key]) {\n              chunkContentHashMap[key] = Object.create(null);\n            }\n            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n          }\n          if (chunk.name) {\n            chunkNameMap[chunk.id] = chunk.name;\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      return {\n        hash: chunkHashMap,\n        contentHash: chunkContentHashMap,\n        name: chunkNameMap\n      };\n    }\n\n    /**\n     * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n     */\n  }, {\n    key: \"getChildIdsByOrders\",\n    value: function getChildIdsByOrders() {\n      var lists = new Map();\n      var _iterator19 = _createForOfIteratorHelper(this.groupsIterable),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var group = _step19.value;\n          if (group.chunks[group.chunks.length - 1] === this) {\n            var _iterator21 = _createForOfIteratorHelper(group.childrenIterable),\n              _step21;\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var childGroup = _step21.value;\n                // TODO webpack 5 remove this check for options\n                if (typeof childGroup.options === \"object\") {\n                  for (var _i4 = 0, _Object$keys2 = Object.keys(childGroup.options); _i4 < _Object$keys2.length; _i4++) {\n                    var key = _Object$keys2[_i4];\n                    if (key.endsWith(\"Order\")) {\n                      var name = key.substr(0, key.length - \"Order\".length);\n                      var list = lists.get(name);\n                      if (list === undefined) lists.set(name, list = []);\n                      list.push({\n                        order: childGroup.options[key],\n                        group: childGroup\n                      });\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      var result = Object.create(null);\n      var _iterator20 = _createForOfIteratorHelper(lists),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _step20$value = _slicedToArray(_step20.value, 2),\n            _name = _step20$value[0],\n            _list = _step20$value[1];\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp;\n            // TODO webpack 5 remove this check of compareTo\n            if (a.group.compareTo) {\n              return a.group.compareTo(b.group);\n            }\n            return 0;\n          });\n          result[_name] = Array.from(_list.reduce(function (set, item) {\n            var _iterator22 = _createForOfIteratorHelper(item.group.chunks),\n              _step22;\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var chunk = _step22.value;\n                set.add(chunk.id);\n              }\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n            return set;\n          }, new Set()));\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"getChildIdsByOrdersMap\",\n    value: function getChildIdsByOrdersMap(includeDirectChildren) {\n      var chunkMaps = Object.create(null);\n      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {\n        var data = chunk.getChildIdsByOrders();\n        for (var _i5 = 0, _Object$keys3 = Object.keys(data); _i5 < _Object$keys3.length; _i5++) {\n          var key = _Object$keys3[_i5];\n          var chunkMap = chunkMaps[key];\n          if (chunkMap === undefined) {\n            chunkMaps[key] = chunkMap = Object.create(null);\n          }\n          chunkMap[chunk.id] = data[key];\n        }\n      };\n      if (includeDirectChildren) {\n        var chunks = new Set();\n        var _iterator23 = _createForOfIteratorHelper(this.groupsIterable),\n          _step23;\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var chunkGroup = _step23.value;\n            var _iterator25 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step25;\n            try {\n              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                var chunk = _step25.value;\n                chunks.add(chunk);\n              }\n            } catch (err) {\n              _iterator25.e(err);\n            } finally {\n              _iterator25.f();\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n        var _iterator24 = _createForOfIteratorHelper(chunks),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var _chunk = _step24.value;\n            addChildIdsByOrdersToMap(_chunk);\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n      var _iterator26 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step26;\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var _chunk2 = _step26.value;\n          addChildIdsByOrdersToMap(_chunk2);\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n      return chunkMaps;\n    }\n\n    /**\n     * @typedef {Object} ChunkModuleMaps\n     * @property {Record<string|number, (string|number)[]>} id\n     * @property {Record<string|number, string>} hash\n     */\n\n    /**\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @returns {ChunkModuleMaps} module map information\n     */\n  }, {\n    key: \"getChunkModuleMaps\",\n    value: function getChunkModuleMaps(filterFn) {\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n      var chunkModuleHashMap = Object.create(null);\n      var _iterator27 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var chunk = _step27.value;\n          /** @type {(string|number)[]} */\n          var array = void 0;\n          var _iterator28 = _createForOfIteratorHelper(chunk.modulesIterable),\n            _step28;\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var _module4 = _step28.value;\n              if (filterFn(_module4)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[chunk.id] = array;\n                }\n                array.push(_module4.id);\n                chunkModuleHashMap[_module4.id] = _module4.renderedHash;\n              }\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n          if (array !== undefined) {\n            array.sort();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      return {\n        id: chunkModuleIdMap,\n        hash: chunkModuleHashMap\n      };\n    }\n\n    /**\n     *\n     * @param {function(Module): boolean} filterFn predicate function used to filter modules\n     * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(filterFn, filterChunkFn) {\n      var queue = new Set(this.groupsIterable);\n      var chunksProcessed = new Set();\n      var _iterator29 = _createForOfIteratorHelper(queue),\n        _step29;\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var chunkGroup = _step29.value;\n          var _iterator30 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step30;\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var chunk = _step30.value;\n              if (!chunksProcessed.has(chunk)) {\n                chunksProcessed.add(chunk);\n                if (!filterChunkFn || filterChunkFn(chunk)) {\n                  var _iterator32 = _createForOfIteratorHelper(chunk.modulesIterable),\n                    _step32;\n                  try {\n                    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                      var _module5 = _step32.value;\n                      if (filterFn(_module5)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator32.e(err);\n                  } finally {\n                    _iterator32.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n          var _iterator31 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step31;\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var child = _step31.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Chunk[\".concat(Array.from(this._modules).join(), \"]\");\n    }\n  }]);\n  return Chunk;\n}(); // TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n   * @param {ForEachModuleCallback} fn Callback function\n   * @returns {void}\n   */\n  function (fn) {\n    this._modules.forEach(fn);\n  }, \"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, number): any} MapModulesCallback\n   * @param {MapModulesCallback} fn Callback function\n   * @returns {TODO[]} result of mapped modules\n   */\n  function (fn) {\n    return Array.from(this._modules, fn);\n  }, \"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n  }\n});\nmodule.exports = Chunk;","map":{"version":3,"names":["util","require","SortableSet","intersect","GraphHelpers","Entrypoint","debugId","ERR_CHUNK_ENTRY","ERR_CHUNK_INITIAL","sortModuleById","a","b","id","sortChunkGroupById","sortByIdentifier","identifier","getModulesIdent","set","sort","str","m","getArray","Array","from","getModulesSize","size","module","Chunk","name","ids","preventIntegration","entryModule","undefined","_modules","filenameTemplate","_groups","files","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","removedModules","Error","data","chunkGroup","isInitial","getRuntimeChunk","has","add","delete","removeChunk","modules","otherChunk","Symbol","iterator","aItem","next","done","bItem","aModuleIdentifier","value","bModuleIdentifier","getFromCache","getFromUnorderedCache","reason","disconnectChunkAndModule","connectChunkAndModule","rewriteChunkInReasons","canBeIntegrated","hasEntryModule","length","moveModule","clear","replaceChunk","addGroup","newChunk","insertChunk","update","join","isAvailable","queue","Set","groupsIterable","isInGroup","parentsIterable","parent","selfHasRuntime","hasRuntime","otherChunkHasRuntime","options","overhead","chunkOverhead","multiplicator","canBeInitial","entryChunkMultiplicator","addMultiplierAndOverhead","modulesSize","integratedModulesSize","otherModule","sortByFn","sortWith","sortModules","chunks","initialChunks","g","childrenIterable","child","chunk","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","getAllAsyncChunks","keys","key","lists","Map","group","childGroup","endsWith","substr","list","get","push","order","result","cmp","compareTo","reduce","item","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","getChildIdsByOrders","chunkMap","filterFn","chunkModuleIdMap","chunkModuleHashMap","array","modulesIterable","filterChunkFn","chunksProcessed","defineProperty","prototype","configurable","deprecate","fn","forEach","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst intersect = require(\"./util/SetHelpers\").intersect;\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst Entrypoint = require(\"./Entrypoint\");\nlet debugId = 1000;\nconst ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nconst ERR_CHUNK_INITIAL =\n\t\"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nconst sortModuleById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nconst sortChunkGroupById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nconst getModulesIdent = set => {\n\tset.sort();\n\tlet str = \"\";\n\tfor (const m of set) {\n\t\tstr += m.identifier() + \"#\";\n\t}\n\treturn str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nconst getArray = set => Array.from(set);\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = set => {\n\tlet size = 0;\n\tfor (const module of set) {\n\t\tsize += module.size();\n\t}\n\treturn size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t */\n\tconstructor(name) {\n\t\t/** @type {number | null} */\n\t\tthis.id = null;\n\t\t/** @type {number[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {Module=} */\n\t\tthis.entryModule = undefined;\n\t\t/** @private @type {SortableSet<Module>} */\n\t\tthis._modules = new SortableSet(undefined, sortByIdentifier);\n\t\t/** @type {string?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, sortChunkGroupById);\n\t\t/** @type {string[]} */\n\t\tthis.files = [];\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Object} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t\tthis.removedModules = undefined;\n\t}\n\n\t/**\n\t * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget entry() {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n\t * @param {never} data The data that was attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset entry(data) {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget initial() {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @param {never} data The data attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset initial(data) {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup.isInitial() &&\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {boolean} if this chunk contains the entry module\n\t */\n\thasEntryModule() {\n\t\treturn !!this.entryModule;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be added to this chunk.\n\t * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n\t */\n\taddModule(module) {\n\t\tif (!this._modules.has(module)) {\n\t\t\tthis._modules.add(module);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be removed from this chunk\n\t * @returns {boolean} returns true if chunk exists and is successfully deleted\n\t */\n\tremoveModule(module) {\n\t\tif (this._modules.delete(module)) {\n\t\t\tmodule.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module[]} modules the new modules to be set\n\t * @returns {void} set new modules to this chunk and return nothing\n\t */\n\tsetModules(modules) {\n\t\tthis._modules = new SortableSet(modules, sortByIdentifier);\n\t}\n\n\t/**\n\t * @returns {number} the amount of modules in chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn this._modules.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet} return the modules SortableSet for this chunk\n\t */\n\tget modulesIterable() {\n\t\treturn this._modules;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n\t */\n\taddGroup(chunkGroup) {\n\t\tif (this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.add(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tif (!this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.delete(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare itself with\n\t * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareTo(otherChunk) {\n\t\tif (this.name && !otherChunk.name) return -1;\n\t\tif (!this.name && otherChunk.name) return 1;\n\t\tif (this.name < otherChunk.name) return -1;\n\t\tif (this.name > otherChunk.name) return 1;\n\t\tif (this._modules.size > otherChunk._modules.size) return -1;\n\t\tif (this._modules.size < otherChunk._modules.size) return 1;\n\t\tthis._modules.sort();\n\t\totherChunk._modules.sort();\n\t\tconst a = this._modules[Symbol.iterator]();\n\t\tconst b = otherChunk._modules[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst bItem = b.next();\n\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\tif (aModuleIdentifier < bModuleIdentifier) return -1;\n\t\t\tif (aModuleIdentifier > bModuleIdentifier) return 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module Module to check\n\t * @returns {boolean} returns true if module does exist in this chunk\n\t */\n\tcontainsModule(module) {\n\t\treturn this._modules.has(module);\n\t}\n\n\t/**\n\t * @returns {Module[]} an array of modules (do not modify)\n\t */\n\tgetModules() {\n\t\treturn this._modules.getFromCache(getArray);\n\t}\n\n\tgetModulesIdent() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesIdent);\n\t}\n\n\t/**\n\t * @param {string=} reason reason why chunk is removed\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup modules\n\t\t// Array.from is used here to create a clone, because removeChunk modifies this._modules\n\t\tfor (const module of Array.from(this._modules)) {\n\t\t\tmodule.removeChunk(this);\n\t\t}\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module module to move\n\t * @param {Chunk} otherChunk other chunk to move it to\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tGraphHelpers.disconnectChunkAndModule(this, module);\n\t\tGraphHelpers.connectChunkAndModule(otherChunk, module);\n\t\tmodule.rewriteChunkInReasons(this, [otherChunk]);\n\t}\n\n\t/**\n\t *\n\t * @param {Chunk} otherChunk the chunk to integrate with\n\t * @param {string} reason reason why the module is being integrated\n\t * @returns {boolean} returns true or false if integration succeeds or fails\n\t */\n\tintegrate(otherChunk, reason) {\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pick a new name for the integrated chunk\n\t\tif (this.name && otherChunk.name) {\n\t\t\tif (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (this.name.length !== otherChunk.name.length) {\n\t\t\t\t\tthis.name =\n\t\t\t\t\t\tthis.name.length < otherChunk.name.length\n\t\t\t\t\t\t\t? this.name\n\t\t\t\t\t\t\t: otherChunk.name;\n\t\t\t\t} else {\n\t\t\t\t\tthis.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n\t\t\t\t}\n\t\t\t} else if (otherChunk.hasEntryModule()) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tthis.name = otherChunk.name;\n\t\t\t}\n\t\t} else if (otherChunk.name) {\n\t\t\tthis.name = otherChunk.name;\n\t\t}\n\n\t\t// Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n\t\tfor (const module of Array.from(otherChunk._modules)) {\n\t\t\totherChunk.moveModule(module, this);\n\t\t}\n\t\totherChunk._modules.clear();\n\n\t\tif (otherChunk.entryModule) {\n\t\t\tthis.entryModule = otherChunk.entryModule;\n\t\t}\n\n\t\tfor (const chunkGroup of otherChunk._groups) {\n\t\t\tchunkGroup.replaceChunk(otherChunk, this);\n\t\t\tthis.addGroup(chunkGroup);\n\t\t}\n\t\totherChunk._groups.clear();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this._modules.size === 0;\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(`${this.id} `);\n\t\thash.update(this.ids ? this.ids.join(\",\") : \"\");\n\t\thash.update(`${this.name || \"\"} `);\n\t\tfor (const m of this._modules) {\n\t\t\thash.update(m.hash);\n\t\t}\n\t}\n\n\tcanBeIntegrated(otherChunk) {\n\t\tif (this.preventIntegration || otherChunk.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * @param {Chunk} a chunk\n\t\t * @param {Chunk} b chunk\n\t\t * @returns {boolean} true, if a is always available when b is reached\n\t\t */\n\t\tconst isAvailable = (a, b) => {\n\t\t\tconst queue = new Set(b.groupsIterable);\n\t\t\tfor (const chunkGroup of queue) {\n\t\t\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\t\t\tif (chunkGroup.isInitial()) return false;\n\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\tqueue.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst selfHasRuntime = this.hasRuntime();\n\t\tconst otherChunkHasRuntime = otherChunk.hasRuntime();\n\n\t\tif (selfHasRuntime !== otherChunkHasRuntime) {\n\t\t\tif (selfHasRuntime) {\n\t\t\t\treturn isAvailable(this, otherChunk);\n\t\t\t} else if (otherChunkHasRuntime) {\n\t\t\t\treturn isAvailable(otherChunk, this);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @param {number} size the size\n\t * @param {Object} options the options passed in\n\t * @returns {number} the multiplier returned\n\t */\n\taddMultiplierAndOverhead(size, options) {\n\t\tconst overhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst multiplicator = this.canBeInitial()\n\t\t\t? options.entryChunkMultiplicator || 10\n\t\t\t: 1;\n\n\t\treturn size * multiplicator + overhead;\n\t}\n\n\t/**\n\t * @returns {number} the size of all modules\n\t */\n\tmodulesSize() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Object} options the size display options\n\t * @returns {number} the chunk size\n\t */\n\tsize(options = {}) {\n\t\treturn this.addMultiplierAndOverhead(this.modulesSize(), options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {TODO} options the options for this function\n\t * @returns {number | false} the size, or false if it can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\t// Chunk if it's possible to integrate this chunk\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet integratedModulesSize = this.modulesSize();\n\t\t// only count modules that do not exist in this chunk!\n\t\tfor (const otherModule of otherChunk._modules) {\n\t\t\tif (!this._modules.has(otherModule)) {\n\t\t\t\tintegratedModulesSize += otherModule.size();\n\t\t\t}\n\t\t}\n\n\t\treturn this.addMultiplierAndOverhead(integratedModulesSize, options);\n\t}\n\n\t/**\n\t * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n\t * @returns {void}\n\t */\n\tsortModules(sortByFn) {\n\t\tthis._modules.sortWith(sortByFn || sortModuleById);\n\t}\n\n\tsortItems() {\n\t\tthis.sortModules();\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkMaps\n\t * @property {Record<string|number, string>} hash\n\t * @property {Record<string|number, Record<string, string>>} contentHash\n\t * @property {Record<string|number, string>} name\n\t */\n\n\t/**\n\t * @param {boolean} realHash should the full hash or the rendered hash be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\n\t/**\n\t * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\t// TODO webpack 5 remove this check for options\n\t\t\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\t\tif (list === undefined) lists.set(name, (list = []));\n\t\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = Array.from(\n\t\t\t\tlist.reduce((set, item) => {\n\t\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\t\tset.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\treturn set;\n\t\t\t\t}, new Set())\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetChildIdsByOrdersMap(includeDirectChildren) {\n\t\tconst chunkMaps = Object.create(null);\n\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders();\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkModuleMaps\n\t * @property {Record<string|number, (string|number)[]>} id\n\t * @property {Record<string|number, string>} hash\n\t */\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[chunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(module.id);\n\t\t\t\t\tchunkModuleHashMap[module.id] = module.renderedHash;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (array !== undefined) {\n\t\t\t\tarray.sort();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param {function(Module): boolean} filterFn predicate function used to filter modules\n\t * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(chunk)) {\n\t\t\t\t\tchunksProcessed.add(chunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(chunk)) {\n\t\t\t\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\ttoString() {\n\t\treturn `Chunk[${Array.from(this._modules).join()}]`;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n\t\t * @param {ForEachModuleCallback} fn Callback function\n\t\t * @returns {void}\n\t\t */\n\t\tfunction(fn) {\n\t\t\tthis._modules.forEach(fn);\n\t\t},\n\t\t\"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, number): any} MapModulesCallback\n\t\t * @param {MapModulesCallback} fn Callback function\n\t\t * @returns {TODO[]} result of mapped modules\n\t\t */\n\t\tfunction(fn) {\n\t\t\treturn Array.from(this._modules, fn);\n\t\t},\n\t\t\"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\n\t\t\t\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\"\n\t\t);\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n\t}\n});\n\nmodule.exports = Chunk;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}