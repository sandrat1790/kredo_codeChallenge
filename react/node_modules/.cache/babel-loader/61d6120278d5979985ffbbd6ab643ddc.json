{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar validateOptions = require(\"schema-utils\");\nvar schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nvar LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nvar addToSetMap = function addToSetMap(map, key, value) {\n  var set = map.get(key);\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\nvar LimitChunkCountPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  function LimitChunkCountPlugin(options) {\n    _classCallCheck(this, LimitChunkCountPlugin);\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n  _createClass(LimitChunkCountPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", function (chunks) {\n          var maxChunks = options.maxChunks;\n          if (!maxChunks) return;\n          if (maxChunks < 1) return;\n          if (chunks.length <= maxChunks) return;\n          var remainingChunksToMerge = chunks.length - maxChunks;\n\n          // order chunks in a deterministic way\n          var orderedChunks = chunks.slice().sort(function (a, b) {\n            return a.compareTo(b);\n          });\n\n          // create a lazy sorted data structure to keep all combinations\n          // this is large. Size = chunks * (chunks - 1) / 2\n          // It uses a multi layer bucket sort plus normal sort in the last layer\n          // It's also lazy so only accessed buckets are sorted\n          var combinations = new LazyBucketSortedSet(\n          // Layer 1: ordered by largest size benefit\n          function (c) {\n            return c.sizeDiff;\n          }, function (a, b) {\n            return b - a;\n          },\n          // Layer 2: ordered by smallest combined size\n          function (c) {\n            return c.integratedSize;\n          }, function (a, b) {\n            return a - b;\n          },\n          // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n          function (c) {\n            return c.bIdx - c.aIdx;\n          }, function (a, b) {\n            return a - b;\n          },\n          // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n          function (a, b) {\n            return a.bIdx - b.bIdx;\n          });\n\n          // we keep a mappng from chunk to all combinations\n          // but this mapping is not kept up-to-date with deletions\n          // so `deleted` flag need to be considered when iterating this\n          /** @type {Map<Chunk, Set<ChunkCombination>>} */\n          var combinationsByChunk = new Map();\n          orderedChunks.forEach(function (b, bIdx) {\n            // create combination pairs with size and integrated size\n            for (var aIdx = 0; aIdx < bIdx; aIdx++) {\n              var a = orderedChunks[aIdx];\n              var integratedSize = a.integratedSize(b, options);\n\n              // filter pairs that do not have an integratedSize\n              // meaning they can NOT be integrated!\n              if (integratedSize === false) continue;\n              var aSize = a.size(options);\n              var bSize = b.size(options);\n              var c = {\n                deleted: false,\n                sizeDiff: aSize + bSize - integratedSize,\n                integratedSize: integratedSize,\n                a: a,\n                b: b,\n                aIdx: aIdx,\n                bIdx: bIdx,\n                aSize: aSize,\n                bSize: bSize\n              };\n              combinations.add(c);\n              addToSetMap(combinationsByChunk, a, c);\n              addToSetMap(combinationsByChunk, b, c);\n            }\n            return combinations;\n          });\n\n          // list of modified chunks during this run\n          // combinations affected by this change are skipped to allow\n          // futher optimizations\n          /** @type {Set<Chunk>} */\n          var modifiedChunks = new Set();\n          var changed = false;\n          // eslint-disable-next-line no-constant-condition\n          loop: while (true) {\n            var combination = combinations.popFirst();\n            if (combination === undefined) break;\n            combination.deleted = true;\n            var a = combination.a,\n              b = combination.b,\n              integratedSize = combination.integratedSize;\n\n            // skip over pair when\n            // one of the already merged chunks is a parent of one of the chunks\n            if (modifiedChunks.size > 0) {\n              var queue = new Set(a.groupsIterable);\n              var _iterator = _createForOfIteratorHelper(b.groupsIterable),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var group = _step.value;\n                  queue.add(group);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              var _iterator2 = _createForOfIteratorHelper(queue),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _group = _step2.value;\n                  var _iterator3 = _createForOfIteratorHelper(modifiedChunks),\n                    _step3;\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      var mChunk = _step3.value;\n                      if (mChunk !== a && mChunk !== b && mChunk.isInGroup(_group)) {\n                        // This is a potential pair which needs recalculation\n                        // We can't do that now, but it merge before following pairs\n                        // so we leave space for it, and consider chunks as modified\n                        // just for the worse case\n                        remainingChunksToMerge--;\n                        if (remainingChunksToMerge <= 0) break loop;\n                        modifiedChunks.add(a);\n                        modifiedChunks.add(b);\n                        continue loop;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n                  var _iterator4 = _createForOfIteratorHelper(_group.parentsIterable),\n                    _step4;\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var parent = _step4.value;\n                      queue.add(parent);\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n\n            // merge the chunks\n            if (a.integrate(b, \"limit\")) {\n              chunks.splice(chunks.indexOf(b), 1);\n\n              // flag chunk a as modified as further optimization are possible for all children here\n              modifiedChunks.add(a);\n              changed = true;\n              remainingChunksToMerge--;\n              if (remainingChunksToMerge <= 0) break;\n\n              // Update all affected combinations\n              // delete all combination with the removed chunk\n              // we will use combinations with the kept chunk instead\n              var _iterator5 = _createForOfIteratorHelper(combinationsByChunk.get(b)),\n                _step5;\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _combination = _step5.value;\n                  if (_combination.deleted) continue;\n                  _combination.deleted = true;\n                  combinations.delete(_combination);\n                }\n\n                // Update combinations with the kept chunk with new sizes\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              var _iterator6 = _createForOfIteratorHelper(combinationsByChunk.get(a)),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _combination2 = _step6.value;\n                  if (_combination2.deleted) continue;\n                  if (_combination2.a === a) {\n                    // Update size\n                    var newIntegratedSize = a.integratedSize(_combination2.b, options);\n                    if (newIntegratedSize === false) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n                    var finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.integratedSize = newIntegratedSize;\n                    _combination2.aSize = integratedSize;\n                    _combination2.sizeDiff = _combination2.bSize + integratedSize - newIntegratedSize;\n                    finishUpdate();\n                  } else if (_combination2.b === a) {\n                    // Update size\n                    var _newIntegratedSize = _combination2.a.integratedSize(a, options);\n                    if (_newIntegratedSize === false) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n                    var _finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.integratedSize = _newIntegratedSize;\n                    _combination2.bSize = integratedSize;\n                    _combination2.sizeDiff = integratedSize + _combination2.aSize - _newIntegratedSize;\n                    _finishUpdate();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            }\n          }\n          if (changed) return true;\n        });\n      });\n    }\n  }]);\n  return LimitChunkCountPlugin;\n}();\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"names":["validateOptions","require","schema","LazyBucketSortedSet","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","options","compiler","hooks","compilation","tap","optimizeChunksAdvanced","chunks","maxChunks","length","remainingChunksToMerge","orderedChunks","slice","sort","a","b","compareTo","combinations","c","sizeDiff","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","aSize","size","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parentsIterable","parent","integrate","splice","indexOf","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Limit Chunk Count Plugin\");\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"LimitChunkCountPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (chunks.length <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = chunks.length - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mappng from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\tconst integratedSize = a.integratedSize(b, options);\n\n\t\t\t\t\t\t\t// filter pairs that do not have an integratedSize\n\t\t\t\t\t\t\t// meaning they can NOT be integrated!\n\t\t\t\t\t\t\tif (integratedSize === false) continue;\n\n\t\t\t\t\t\t\tconst aSize = a.size(options);\n\t\t\t\t\t\t\tconst bSize = b.size(options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// futher optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (a.integrate(b, \"limit\")) {\n\t\t\t\t\t\t\tchunks.splice(chunks.indexOf(b), 1);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = a.integratedSize(\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = combination.a.integratedSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}