{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/myCodes/KredoCodeChallenge/react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n  REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n  REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n  REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n  REGEXP_NAME = /\\[name\\]/gi,\n  REGEXP_ID = /\\[id\\]/gi,\n  REGEXP_MODULEID = /\\[moduleid\\]/gi,\n  REGEXP_FILE = /\\[file\\]/gi,\n  REGEXP_QUERY = /\\[query\\]/gi,\n  REGEXP_FILEBASE = /\\[filebase\\]/gi,\n  REGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nvar REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n  REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n  REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n  REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\nvar withHashLength = function withHashLength(replacer, handlerFn, assetInfo) {\n  var fn = function fn(match, hashLength) {\n    if (assetInfo) assetInfo.immutable = true;\n    var length = hashLength && parseInt(hashLength, 10);\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    var hash = replacer.apply(void 0, [match, hashLength].concat(args));\n    return length ? hash.slice(0, length) : hash;\n  };\n  return fn;\n};\nvar getReplacer = function getReplacer(value, allowEmpty) {\n  var fn = function fn(match) {\n    var _ref;\n    // last argument in replacer is the entire input string\n    var input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(\"Path variable \".concat(match, \" not implemented in this context: \").concat(input));\n      }\n      return \"\";\n    } else {\n      return \"\".concat(escapePathVariables(value));\n    }\n  };\n  return fn;\n};\nvar escapePathVariables = function escapePathVariables(value) {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\nvar replacePathVariables = function replacePathVariables(path, data, assetInfo) {\n  var chunk = data.chunk;\n  var chunkId = chunk && chunk.id;\n  var chunkName = chunk && (chunk.name || chunk.id);\n  var chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  var chunkHashWithLength = chunk && chunk.hashWithLength;\n  var contentHashType = data.contentHashType;\n  var contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  var contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  var module = data.module;\n  var moduleId = module && module.id;\n  var moduleHash = module && (module.renderedHash || module.hash);\n  var moduleHashWithLength = module && module.hashWithLength;\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(\"Cannot use [chunkhash] or [contenthash] for chunk in '\".concat(path, \"' (use [hash] instead)\"));\n  }\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename))\n  // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true))\n  // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\nvar TemplatedPathPlugin = /*#__PURE__*/function () {\n  function TemplatedPathPlugin() {\n    _classCallCheck(this, TemplatedPathPlugin);\n  }\n  _createClass(TemplatedPathPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", function (compilation) {\n        var mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n        mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", function (chunk, paths) {\n          var outputOptions = mainTemplate.outputOptions;\n          var publicPath = outputOptions.publicPath || \"\";\n          var filename = outputOptions.filename || \"\";\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n          if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n        });\n        mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", function (hash, chunk) {\n          var outputOptions = mainTemplate.outputOptions;\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n          if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n          }\n          if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n          }\n          if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n          }\n        });\n      });\n    }\n  }]);\n  return TemplatedPathPlugin;\n}();\nmodule.exports = TemplatedPathPlugin;","map":{"version":3,"names":["REGEXP_HASH","REGEXP_CHUNKHASH","REGEXP_MODULEHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_ID","REGEXP_MODULEID","REGEXP_FILE","REGEXP_QUERY","REGEXP_FILEBASE","REGEXP_URL","REGEXP_HASH_FOR_TEST","RegExp","source","REGEXP_CHUNKHASH_FOR_TEST","REGEXP_CONTENTHASH_FOR_TEST","REGEXP_NAME_FOR_TEST","withHashLength","replacer","handlerFn","assetInfo","fn","match","hashLength","immutable","length","parseInt","args","hash","slice","getReplacer","value","allowEmpty","input","undefined","Error","escapePathVariables","replace","replacePathVariables","path","data","chunk","chunkId","id","chunkName","name","chunkHash","renderedHash","chunkHashWithLength","hashWithLength","contentHashType","contentHash","contentHashWithLength","module","moduleId","moduleHash","moduleHashWithLength","noChunkHash","test","filename","basename","query","url","TemplatedPathPlugin","compiler","hooks","compilation","tap","mainTemplate","assetPath","globalHash","paths","outputOptions","publicPath","chunkFilename","join","hashForChunk","update","JSON","stringify","getChunkMaps","javascript","exports"],"sources":["C:/myCodes/KredoCodeChallenge/react/node_modules/webpack/lib/TemplatedPathPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n\tREGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n\tREGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n\tREGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n\tREGEXP_NAME = /\\[name\\]/gi,\n\tREGEXP_ID = /\\[id\\]/gi,\n\tREGEXP_MODULEID = /\\[moduleid\\]/gi,\n\tREGEXP_FILE = /\\[file\\]/gi,\n\tREGEXP_QUERY = /\\[query\\]/gi,\n\tREGEXP_FILEBASE = /\\[filebase\\]/gi,\n\tREGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n\tREGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n\tREGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n\tREGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n\tconst fn = (match, hashLength, ...args) => {\n\t\tif (assetInfo) assetInfo.immutable = true;\n\t\tconst length = hashLength && parseInt(hashLength, 10);\n\t\tif (length && handlerFn) {\n\t\t\treturn handlerFn(length);\n\t\t}\n\t\tconst hash = replacer(match, hashLength, ...args);\n\t\treturn length ? hash.slice(0, length) : hash;\n\t};\n\treturn fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n\tconst fn = (match, ...args) => {\n\t\t// last argument in replacer is the entire input string\n\t\tconst input = args[args.length - 1];\n\t\tif (value === null || value === undefined) {\n\t\t\tif (!allowEmpty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Path variable ${match} not implemented in this context: ${input}`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn `${escapePathVariables(value)}`;\n\t\t}\n\t};\n\treturn fn;\n};\n\nconst escapePathVariables = value => {\n\treturn typeof value === \"string\"\n\t\t? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\")\n\t\t: value;\n};\n\nconst replacePathVariables = (path, data, assetInfo) => {\n\tconst chunk = data.chunk;\n\tconst chunkId = chunk && chunk.id;\n\tconst chunkName = chunk && (chunk.name || chunk.id);\n\tconst chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n\tconst chunkHashWithLength = chunk && chunk.hashWithLength;\n\tconst contentHashType = data.contentHashType;\n\tconst contentHash =\n\t\t(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||\n\t\tdata.contentHash;\n\tconst contentHashWithLength =\n\t\t(chunk &&\n\t\t\tchunk.contentHashWithLength &&\n\t\t\tchunk.contentHashWithLength[contentHashType]) ||\n\t\tdata.contentHashWithLength;\n\tconst module = data.module;\n\tconst moduleId = module && module.id;\n\tconst moduleHash = module && (module.renderedHash || module.hash);\n\tconst moduleHashWithLength = module && module.hashWithLength;\n\n\tif (typeof path === \"function\") {\n\t\tpath = path(data);\n\t}\n\n\tif (\n\t\tdata.noChunkHash &&\n\t\t(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||\n\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(path))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`\n\t\t);\n\t}\n\n\treturn (\n\t\tpath\n\t\t\t.replace(\n\t\t\t\tREGEXP_HASH,\n\t\t\t\twithHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CHUNKHASH,\n\t\t\t\twithHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CONTENTHASH,\n\t\t\t\twithHashLength(\n\t\t\t\t\tgetReplacer(contentHash),\n\t\t\t\t\tcontentHashWithLength,\n\t\t\t\t\tassetInfo\n\t\t\t\t)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_MODULEHASH,\n\t\t\t\twithHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(REGEXP_ID, getReplacer(chunkId))\n\t\t\t.replace(REGEXP_MODULEID, getReplacer(moduleId))\n\t\t\t.replace(REGEXP_NAME, getReplacer(chunkName))\n\t\t\t.replace(REGEXP_FILE, getReplacer(data.filename))\n\t\t\t.replace(REGEXP_FILEBASE, getReplacer(data.basename))\n\t\t\t// query is optional, it's OK if it's in a path but there's nothing to replace it with\n\t\t\t.replace(REGEXP_QUERY, getReplacer(data.query, true))\n\t\t\t// only available in sourceMappingURLComment\n\t\t\t.replace(REGEXP_URL, getReplacer(data.url))\n\t\t\t.replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\")\n\t);\n};\n\nclass TemplatedPathPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n\t\t\tconst mainTemplate = compilation.mainTemplate;\n\n\t\t\tmainTemplate.hooks.assetPath.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\treplacePathVariables\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.globalHash.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(chunk, paths) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst publicPath = outputOptions.publicPath || \"\";\n\t\t\t\t\tconst filename = outputOptions.filename || \"\";\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (\n\t\t\t\t\t\tREGEXP_HASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_NAME_FOR_TEST.test(publicPath)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.hashForChunk.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(hash, chunk) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\tchunk.getChunkMaps(true).contentHash.javascript || {}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = TemplatedPathPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}